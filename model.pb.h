// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_model_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_model_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_model_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_model_2eproto {
  static const uint32_t offsets[];
};
namespace model {
class Animations;
struct AnimationsDefaultTypeInternal;
extern AnimationsDefaultTypeInternal _Animations_default_instance_;
class Animations_Channel;
struct Animations_ChannelDefaultTypeInternal;
extern Animations_ChannelDefaultTypeInternal _Animations_Channel_default_instance_;
class Animations_keys;
struct Animations_keysDefaultTypeInternal;
extern Animations_keysDefaultTypeInternal _Animations_keys_default_instance_;
class Materials;
struct MaterialsDefaultTypeInternal;
extern MaterialsDefaultTypeInternal _Materials_default_instance_;
class Materials_PropertyEntry;
struct Materials_PropertyEntryDefaultTypeInternal;
extern Materials_PropertyEntryDefaultTypeInternal _Materials_PropertyEntry_default_instance_;
class Meshes;
struct MeshesDefaultTypeInternal;
extern MeshesDefaultTypeInternal _Meshes_default_instance_;
class Meshes_BonesEntry;
struct Meshes_BonesEntryDefaultTypeInternal;
extern Meshes_BonesEntryDefaultTypeInternal _Meshes_BonesEntry_default_instance_;
class Meshes_BonesWeight;
struct Meshes_BonesWeightDefaultTypeInternal;
extern Meshes_BonesWeightDefaultTypeInternal _Meshes_BonesWeight_default_instance_;
class Meshes_FaceEntry;
struct Meshes_FaceEntryDefaultTypeInternal;
extern Meshes_FaceEntryDefaultTypeInternal _Meshes_FaceEntry_default_instance_;
class Meshes_TexturecoordsEntry;
struct Meshes_TexturecoordsEntryDefaultTypeInternal;
extern Meshes_TexturecoordsEntryDefaultTypeInternal _Meshes_TexturecoordsEntry_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
}  // namespace model
PROTOBUF_NAMESPACE_OPEN
template<> ::model::Animations* Arena::CreateMaybeMessage<::model::Animations>(Arena*);
template<> ::model::Animations_Channel* Arena::CreateMaybeMessage<::model::Animations_Channel>(Arena*);
template<> ::model::Animations_keys* Arena::CreateMaybeMessage<::model::Animations_keys>(Arena*);
template<> ::model::Materials* Arena::CreateMaybeMessage<::model::Materials>(Arena*);
template<> ::model::Materials_PropertyEntry* Arena::CreateMaybeMessage<::model::Materials_PropertyEntry>(Arena*);
template<> ::model::Meshes* Arena::CreateMaybeMessage<::model::Meshes>(Arena*);
template<> ::model::Meshes_BonesEntry* Arena::CreateMaybeMessage<::model::Meshes_BonesEntry>(Arena*);
template<> ::model::Meshes_BonesWeight* Arena::CreateMaybeMessage<::model::Meshes_BonesWeight>(Arena*);
template<> ::model::Meshes_FaceEntry* Arena::CreateMaybeMessage<::model::Meshes_FaceEntry>(Arena*);
template<> ::model::Meshes_TexturecoordsEntry* Arena::CreateMaybeMessage<::model::Meshes_TexturecoordsEntry>(Arena*);
template<> ::model::Model* Arena::CreateMaybeMessage<::model::Model>(Arena*);
template<> ::model::Node* Arena::CreateMaybeMessage<::model::Node>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace model {

// ===================================================================

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformationFieldNumber = 2,
    kMeshesFieldNumber = 3,
    kChildrenFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // repeated float transformation = 2;
  int transformation_size() const;
  private:
  int _internal_transformation_size() const;
  public:
  void clear_transformation();
  private:
  float _internal_transformation(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_transformation() const;
  void _internal_add_transformation(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_transformation();
  public:
  float transformation(int index) const;
  void set_transformation(int index, float value);
  void add_transformation(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      transformation() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_transformation();

  // repeated int32 meshes = 3;
  int meshes_size() const;
  private:
  int _internal_meshes_size() const;
  public:
  void clear_meshes();
  private:
  int32_t _internal_meshes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_meshes() const;
  void _internal_add_meshes(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_meshes();
  public:
  int32_t meshes(int index) const;
  void set_meshes(int index, int32_t value);
  void add_meshes(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      meshes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_meshes();

  // repeated .model.Node children = 4;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::model::Node* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Node >*
      mutable_children();
  private:
  const ::model::Node& _internal_children(int index) const;
  ::model::Node* _internal_add_children();
  public:
  const ::model::Node& children(int index) const;
  ::model::Node* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Node >&
      children() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:model.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > transformation_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > meshes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Node > children_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Meshes_TexturecoordsEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Meshes.TexturecoordsEntry) */ {
 public:
  inline Meshes_TexturecoordsEntry() : Meshes_TexturecoordsEntry(nullptr) {}
  ~Meshes_TexturecoordsEntry() override;
  explicit PROTOBUF_CONSTEXPR Meshes_TexturecoordsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meshes_TexturecoordsEntry(const Meshes_TexturecoordsEntry& from);
  Meshes_TexturecoordsEntry(Meshes_TexturecoordsEntry&& from) noexcept
    : Meshes_TexturecoordsEntry() {
    *this = ::std::move(from);
  }

  inline Meshes_TexturecoordsEntry& operator=(const Meshes_TexturecoordsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meshes_TexturecoordsEntry& operator=(Meshes_TexturecoordsEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Meshes_TexturecoordsEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meshes_TexturecoordsEntry* internal_default_instance() {
    return reinterpret_cast<const Meshes_TexturecoordsEntry*>(
               &_Meshes_TexturecoordsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Meshes_TexturecoordsEntry& a, Meshes_TexturecoordsEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(Meshes_TexturecoordsEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meshes_TexturecoordsEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meshes_TexturecoordsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Meshes_TexturecoordsEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Meshes_TexturecoordsEntry& from);
  void MergeFrom(const Meshes_TexturecoordsEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Meshes_TexturecoordsEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Meshes.TexturecoordsEntry";
  }
  protected:
  explicit Meshes_TexturecoordsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:model.Meshes.TexturecoordsEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Meshes_BonesWeight final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Meshes.BonesWeight) */ {
 public:
  inline Meshes_BonesWeight() : Meshes_BonesWeight(nullptr) {}
  ~Meshes_BonesWeight() override;
  explicit PROTOBUF_CONSTEXPR Meshes_BonesWeight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meshes_BonesWeight(const Meshes_BonesWeight& from);
  Meshes_BonesWeight(Meshes_BonesWeight&& from) noexcept
    : Meshes_BonesWeight() {
    *this = ::std::move(from);
  }

  inline Meshes_BonesWeight& operator=(const Meshes_BonesWeight& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meshes_BonesWeight& operator=(Meshes_BonesWeight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Meshes_BonesWeight& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meshes_BonesWeight* internal_default_instance() {
    return reinterpret_cast<const Meshes_BonesWeight*>(
               &_Meshes_BonesWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Meshes_BonesWeight& a, Meshes_BonesWeight& b) {
    a.Swap(&b);
  }
  inline void Swap(Meshes_BonesWeight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meshes_BonesWeight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meshes_BonesWeight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Meshes_BonesWeight>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Meshes_BonesWeight& from);
  void MergeFrom(const Meshes_BonesWeight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Meshes_BonesWeight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Meshes.BonesWeight";
  }
  protected:
  explicit Meshes_BonesWeight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated int32 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  int32_t _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_data() const;
  void _internal_add_data(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_data();
  public:
  int32_t data(int index) const;
  void set_data(int index, int32_t value);
  void add_data(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:model.Meshes.BonesWeight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Meshes_BonesEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Meshes.BonesEntry) */ {
 public:
  inline Meshes_BonesEntry() : Meshes_BonesEntry(nullptr) {}
  ~Meshes_BonesEntry() override;
  explicit PROTOBUF_CONSTEXPR Meshes_BonesEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meshes_BonesEntry(const Meshes_BonesEntry& from);
  Meshes_BonesEntry(Meshes_BonesEntry&& from) noexcept
    : Meshes_BonesEntry() {
    *this = ::std::move(from);
  }

  inline Meshes_BonesEntry& operator=(const Meshes_BonesEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meshes_BonesEntry& operator=(Meshes_BonesEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Meshes_BonesEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meshes_BonesEntry* internal_default_instance() {
    return reinterpret_cast<const Meshes_BonesEntry*>(
               &_Meshes_BonesEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Meshes_BonesEntry& a, Meshes_BonesEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(Meshes_BonesEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meshes_BonesEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meshes_BonesEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Meshes_BonesEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Meshes_BonesEntry& from);
  void MergeFrom(const Meshes_BonesEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Meshes_BonesEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Meshes.BonesEntry";
  }
  protected:
  explicit Meshes_BonesEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetmatrixFieldNumber = 2,
    kWeightsFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated float offsetmatrix = 2;
  int offsetmatrix_size() const;
  private:
  int _internal_offsetmatrix_size() const;
  public:
  void clear_offsetmatrix();
  private:
  float _internal_offsetmatrix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_offsetmatrix() const;
  void _internal_add_offsetmatrix(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_offsetmatrix();
  public:
  float offsetmatrix(int index) const;
  void set_offsetmatrix(int index, float value);
  void add_offsetmatrix(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      offsetmatrix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_offsetmatrix();

  // repeated .model.Meshes.BonesWeight weights = 3;
  int weights_size() const;
  private:
  int _internal_weights_size() const;
  public:
  void clear_weights();
  ::model::Meshes_BonesWeight* mutable_weights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesWeight >*
      mutable_weights();
  private:
  const ::model::Meshes_BonesWeight& _internal_weights(int index) const;
  ::model::Meshes_BonesWeight* _internal_add_weights();
  public:
  const ::model::Meshes_BonesWeight& weights(int index) const;
  ::model::Meshes_BonesWeight* add_weights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesWeight >&
      weights() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:model.Meshes.BonesEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > offsetmatrix_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesWeight > weights_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Meshes_FaceEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Meshes.FaceEntry) */ {
 public:
  inline Meshes_FaceEntry() : Meshes_FaceEntry(nullptr) {}
  ~Meshes_FaceEntry() override;
  explicit PROTOBUF_CONSTEXPR Meshes_FaceEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meshes_FaceEntry(const Meshes_FaceEntry& from);
  Meshes_FaceEntry(Meshes_FaceEntry&& from) noexcept
    : Meshes_FaceEntry() {
    *this = ::std::move(from);
  }

  inline Meshes_FaceEntry& operator=(const Meshes_FaceEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meshes_FaceEntry& operator=(Meshes_FaceEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Meshes_FaceEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meshes_FaceEntry* internal_default_instance() {
    return reinterpret_cast<const Meshes_FaceEntry*>(
               &_Meshes_FaceEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Meshes_FaceEntry& a, Meshes_FaceEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(Meshes_FaceEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meshes_FaceEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meshes_FaceEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Meshes_FaceEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Meshes_FaceEntry& from);
  void MergeFrom(const Meshes_FaceEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Meshes_FaceEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Meshes.FaceEntry";
  }
  protected:
  explicit Meshes_FaceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated int32 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  int32_t _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_data() const;
  void _internal_add_data(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_data();
  public:
  int32_t data(int index) const;
  void set_data(int index, int32_t value);
  void add_data(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:model.Meshes.FaceEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Meshes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Meshes) */ {
 public:
  inline Meshes() : Meshes(nullptr) {}
  ~Meshes() override;
  explicit PROTOBUF_CONSTEXPR Meshes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meshes(const Meshes& from);
  Meshes(Meshes&& from) noexcept
    : Meshes() {
    *this = ::std::move(from);
  }

  inline Meshes& operator=(const Meshes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meshes& operator=(Meshes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Meshes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meshes* internal_default_instance() {
    return reinterpret_cast<const Meshes*>(
               &_Meshes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Meshes& a, Meshes& b) {
    a.Swap(&b);
  }
  inline void Swap(Meshes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meshes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meshes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Meshes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Meshes& from);
  void MergeFrom(const Meshes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Meshes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Meshes";
  }
  protected:
  explicit Meshes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Meshes_TexturecoordsEntry TexturecoordsEntry;
  typedef Meshes_BonesWeight BonesWeight;
  typedef Meshes_BonesEntry BonesEntry;
  typedef Meshes_FaceEntry FaceEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 4,
    kNormalsFieldNumber = 5,
    kNumuvcomponentsFieldNumber = 6,
    kTexturecoordsFieldNumber = 7,
    kBonesFieldNumber = 8,
    kFacesFieldNumber = 9,
    kNameFieldNumber = 1,
    kMaterialindexFieldNumber = 2,
    kPrimitivetypesFieldNumber = 3,
  };
  // repeated float vertices = 4;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  private:
  float _internal_vertices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vertices() const;
  void _internal_add_vertices(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vertices();
  public:
  float vertices(int index) const;
  void set_vertices(int index, float value);
  void add_vertices(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vertices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vertices();

  // repeated float normals = 5;
  int normals_size() const;
  private:
  int _internal_normals_size() const;
  public:
  void clear_normals();
  private:
  float _internal_normals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_normals() const;
  void _internal_add_normals(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_normals();
  public:
  float normals(int index) const;
  void set_normals(int index, float value);
  void add_normals(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      normals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_normals();

  // repeated int32 numuvcomponents = 6;
  int numuvcomponents_size() const;
  private:
  int _internal_numuvcomponents_size() const;
  public:
  void clear_numuvcomponents();
  private:
  int32_t _internal_numuvcomponents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_numuvcomponents() const;
  void _internal_add_numuvcomponents(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_numuvcomponents();
  public:
  int32_t numuvcomponents(int index) const;
  void set_numuvcomponents(int index, int32_t value);
  void add_numuvcomponents(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      numuvcomponents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_numuvcomponents();

  // repeated .model.Meshes.TexturecoordsEntry texturecoords = 7;
  int texturecoords_size() const;
  private:
  int _internal_texturecoords_size() const;
  public:
  void clear_texturecoords();
  ::model::Meshes_TexturecoordsEntry* mutable_texturecoords(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_TexturecoordsEntry >*
      mutable_texturecoords();
  private:
  const ::model::Meshes_TexturecoordsEntry& _internal_texturecoords(int index) const;
  ::model::Meshes_TexturecoordsEntry* _internal_add_texturecoords();
  public:
  const ::model::Meshes_TexturecoordsEntry& texturecoords(int index) const;
  ::model::Meshes_TexturecoordsEntry* add_texturecoords();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_TexturecoordsEntry >&
      texturecoords() const;

  // repeated .model.Meshes.BonesEntry bones = 8;
  int bones_size() const;
  private:
  int _internal_bones_size() const;
  public:
  void clear_bones();
  ::model::Meshes_BonesEntry* mutable_bones(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesEntry >*
      mutable_bones();
  private:
  const ::model::Meshes_BonesEntry& _internal_bones(int index) const;
  ::model::Meshes_BonesEntry* _internal_add_bones();
  public:
  const ::model::Meshes_BonesEntry& bones(int index) const;
  ::model::Meshes_BonesEntry* add_bones();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesEntry >&
      bones() const;

  // repeated .model.Meshes.FaceEntry faces = 9;
  int faces_size() const;
  private:
  int _internal_faces_size() const;
  public:
  void clear_faces();
  ::model::Meshes_FaceEntry* mutable_faces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_FaceEntry >*
      mutable_faces();
  private:
  const ::model::Meshes_FaceEntry& _internal_faces(int index) const;
  ::model::Meshes_FaceEntry* _internal_add_faces();
  public:
  const ::model::Meshes_FaceEntry& faces(int index) const;
  ::model::Meshes_FaceEntry* add_faces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_FaceEntry >&
      faces() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 materialindex = 2;
  bool has_materialindex() const;
  private:
  bool _internal_has_materialindex() const;
  public:
  void clear_materialindex();
  int32_t materialindex() const;
  void set_materialindex(int32_t value);
  private:
  int32_t _internal_materialindex() const;
  void _internal_set_materialindex(int32_t value);
  public:

  // optional int32 primitivetypes = 3;
  bool has_primitivetypes() const;
  private:
  bool _internal_has_primitivetypes() const;
  public:
  void clear_primitivetypes();
  int32_t primitivetypes() const;
  void set_primitivetypes(int32_t value);
  private:
  int32_t _internal_primitivetypes() const;
  void _internal_set_primitivetypes(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:model.Meshes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vertices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > normals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > numuvcomponents_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_TexturecoordsEntry > texturecoords_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesEntry > bones_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_FaceEntry > faces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t materialindex_;
  int32_t primitivetypes_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Materials_PropertyEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Materials.PropertyEntry) */ {
 public:
  inline Materials_PropertyEntry() : Materials_PropertyEntry(nullptr) {}
  ~Materials_PropertyEntry() override;
  explicit PROTOBUF_CONSTEXPR Materials_PropertyEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Materials_PropertyEntry(const Materials_PropertyEntry& from);
  Materials_PropertyEntry(Materials_PropertyEntry&& from) noexcept
    : Materials_PropertyEntry() {
    *this = ::std::move(from);
  }

  inline Materials_PropertyEntry& operator=(const Materials_PropertyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Materials_PropertyEntry& operator=(Materials_PropertyEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Materials_PropertyEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Materials_PropertyEntry* internal_default_instance() {
    return reinterpret_cast<const Materials_PropertyEntry*>(
               &_Materials_PropertyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Materials_PropertyEntry& a, Materials_PropertyEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(Materials_PropertyEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Materials_PropertyEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Materials_PropertyEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Materials_PropertyEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Materials_PropertyEntry& from);
  void MergeFrom(const Materials_PropertyEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Materials_PropertyEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Materials.PropertyEntry";
  }
  protected:
  explicit Materials_PropertyEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFarrayFieldNumber = 5,
    kKeyFieldNumber = 1,
    kSvalueFieldNumber = 9,
    kSemanticFieldNumber = 2,
    kIndexFieldNumber = 3,
    kTypeFieldNumber = 4,
    kFvalueFieldNumber = 7,
  };
  // repeated float farray = 5;
  int farray_size() const;
  private:
  int _internal_farray_size() const;
  public:
  void clear_farray();
  private:
  float _internal_farray(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_farray() const;
  void _internal_add_farray(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_farray();
  public:
  float farray(int index) const;
  void set_farray(int index, float value);
  void add_farray(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      farray() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_farray();

  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string svalue = 9;
  bool has_svalue() const;
  private:
  bool _internal_has_svalue() const;
  public:
  void clear_svalue();
  const std::string& svalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_svalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_svalue();
  PROTOBUF_NODISCARD std::string* release_svalue();
  void set_allocated_svalue(std::string* svalue);
  private:
  const std::string& _internal_svalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_svalue(const std::string& value);
  std::string* _internal_mutable_svalue();
  public:

  // optional int32 semantic = 2;
  bool has_semantic() const;
  private:
  bool _internal_has_semantic() const;
  public:
  void clear_semantic();
  int32_t semantic() const;
  void set_semantic(int32_t value);
  private:
  int32_t _internal_semantic() const;
  void _internal_set_semantic(int32_t value);
  public:

  // optional int32 index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // optional int32 type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional float fvalue = 7;
  bool has_fvalue() const;
  private:
  bool _internal_has_fvalue() const;
  public:
  void clear_fvalue();
  float fvalue() const;
  void set_fvalue(float value);
  private:
  float _internal_fvalue() const;
  void _internal_set_fvalue(float value);
  public:

  // @@protoc_insertion_point(class_scope:model.Materials.PropertyEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > farray_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr svalue_;
  int32_t semantic_;
  int32_t index_;
  int32_t type_;
  float fvalue_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Materials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Materials) */ {
 public:
  inline Materials() : Materials(nullptr) {}
  ~Materials() override;
  explicit PROTOBUF_CONSTEXPR Materials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Materials(const Materials& from);
  Materials(Materials&& from) noexcept
    : Materials() {
    *this = ::std::move(from);
  }

  inline Materials& operator=(const Materials& from) {
    CopyFrom(from);
    return *this;
  }
  inline Materials& operator=(Materials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Materials& default_instance() {
    return *internal_default_instance();
  }
  static inline const Materials* internal_default_instance() {
    return reinterpret_cast<const Materials*>(
               &_Materials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Materials& a, Materials& b) {
    a.Swap(&b);
  }
  inline void Swap(Materials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Materials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Materials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Materials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Materials& from);
  void MergeFrom(const Materials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Materials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Materials";
  }
  protected:
  explicit Materials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Materials_PropertyEntry PropertyEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 1,
  };
  // repeated .model.Materials.PropertyEntry properties = 1;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::model::Materials_PropertyEntry* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials_PropertyEntry >*
      mutable_properties();
  private:
  const ::model::Materials_PropertyEntry& _internal_properties(int index) const;
  ::model::Materials_PropertyEntry* _internal_add_properties();
  public:
  const ::model::Materials_PropertyEntry& properties(int index) const;
  ::model::Materials_PropertyEntry* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials_PropertyEntry >&
      properties() const;

  // @@protoc_insertion_point(class_scope:model.Materials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials_PropertyEntry > properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Animations_keys final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Animations.keys) */ {
 public:
  inline Animations_keys() : Animations_keys(nullptr) {}
  ~Animations_keys() override;
  explicit PROTOBUF_CONSTEXPR Animations_keys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Animations_keys(const Animations_keys& from);
  Animations_keys(Animations_keys&& from) noexcept
    : Animations_keys() {
    *this = ::std::move(from);
  }

  inline Animations_keys& operator=(const Animations_keys& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animations_keys& operator=(Animations_keys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Animations_keys& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animations_keys* internal_default_instance() {
    return reinterpret_cast<const Animations_keys*>(
               &_Animations_keys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Animations_keys& a, Animations_keys& b) {
    a.Swap(&b);
  }
  inline void Swap(Animations_keys* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animations_keys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animations_keys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Animations_keys>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Animations_keys& from);
  void MergeFrom(const Animations_keys& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Animations_keys* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Animations.keys";
  }
  protected:
  explicit Animations_keys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVal2FieldNumber = 2,
    kVal1FieldNumber = 1,
  };
  // repeated float val2 = 2;
  int val2_size() const;
  private:
  int _internal_val2_size() const;
  public:
  void clear_val2();
  private:
  float _internal_val2(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_val2() const;
  void _internal_add_val2(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_val2();
  public:
  float val2(int index) const;
  void set_val2(int index, float value);
  void add_val2(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      val2() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_val2();

  // optional int32 val1 = 1;
  bool has_val1() const;
  private:
  bool _internal_has_val1() const;
  public:
  void clear_val1();
  int32_t val1() const;
  void set_val1(int32_t value);
  private:
  int32_t _internal_val1() const;
  void _internal_set_val1(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:model.Animations.keys)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > val2_;
  int32_t val1_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Animations_Channel final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Animations.Channel) */ {
 public:
  inline Animations_Channel() : Animations_Channel(nullptr) {}
  ~Animations_Channel() override;
  explicit PROTOBUF_CONSTEXPR Animations_Channel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Animations_Channel(const Animations_Channel& from);
  Animations_Channel(Animations_Channel&& from) noexcept
    : Animations_Channel() {
    *this = ::std::move(from);
  }

  inline Animations_Channel& operator=(const Animations_Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animations_Channel& operator=(Animations_Channel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Animations_Channel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animations_Channel* internal_default_instance() {
    return reinterpret_cast<const Animations_Channel*>(
               &_Animations_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Animations_Channel& a, Animations_Channel& b) {
    a.Swap(&b);
  }
  inline void Swap(Animations_Channel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animations_Channel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animations_Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Animations_Channel>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Animations_Channel& from);
  void MergeFrom(const Animations_Channel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Animations_Channel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Animations.Channel";
  }
  protected:
  explicit Animations_Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionkeysFieldNumber = 4,
    kRotationkeysFieldNumber = 5,
    kScalingkeysFieldNumber = 6,
    kNameFieldNumber = 1,
    kPrestateFieldNumber = 2,
    kPoststateFieldNumber = 3,
  };
  // repeated .model.Animations.keys positionkeys = 4;
  int positionkeys_size() const;
  private:
  int _internal_positionkeys_size() const;
  public:
  void clear_positionkeys();
  ::model::Animations_keys* mutable_positionkeys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >*
      mutable_positionkeys();
  private:
  const ::model::Animations_keys& _internal_positionkeys(int index) const;
  ::model::Animations_keys* _internal_add_positionkeys();
  public:
  const ::model::Animations_keys& positionkeys(int index) const;
  ::model::Animations_keys* add_positionkeys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >&
      positionkeys() const;

  // repeated .model.Animations.keys rotationkeys = 5;
  int rotationkeys_size() const;
  private:
  int _internal_rotationkeys_size() const;
  public:
  void clear_rotationkeys();
  ::model::Animations_keys* mutable_rotationkeys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >*
      mutable_rotationkeys();
  private:
  const ::model::Animations_keys& _internal_rotationkeys(int index) const;
  ::model::Animations_keys* _internal_add_rotationkeys();
  public:
  const ::model::Animations_keys& rotationkeys(int index) const;
  ::model::Animations_keys* add_rotationkeys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >&
      rotationkeys() const;

  // repeated .model.Animations.keys scalingkeys = 6;
  int scalingkeys_size() const;
  private:
  int _internal_scalingkeys_size() const;
  public:
  void clear_scalingkeys();
  ::model::Animations_keys* mutable_scalingkeys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >*
      mutable_scalingkeys();
  private:
  const ::model::Animations_keys& _internal_scalingkeys(int index) const;
  ::model::Animations_keys* _internal_add_scalingkeys();
  public:
  const ::model::Animations_keys& scalingkeys(int index) const;
  ::model::Animations_keys* add_scalingkeys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >&
      scalingkeys() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 prestate = 2;
  bool has_prestate() const;
  private:
  bool _internal_has_prestate() const;
  public:
  void clear_prestate();
  int32_t prestate() const;
  void set_prestate(int32_t value);
  private:
  int32_t _internal_prestate() const;
  void _internal_set_prestate(int32_t value);
  public:

  // optional int32 poststate = 3;
  bool has_poststate() const;
  private:
  bool _internal_has_poststate() const;
  public:
  void clear_poststate();
  int32_t poststate() const;
  void set_poststate(int32_t value);
  private:
  int32_t _internal_poststate() const;
  void _internal_set_poststate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:model.Animations.Channel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys > positionkeys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys > rotationkeys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys > scalingkeys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t prestate_;
  int32_t poststate_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Animations final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Animations) */ {
 public:
  inline Animations() : Animations(nullptr) {}
  ~Animations() override;
  explicit PROTOBUF_CONSTEXPR Animations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Animations(const Animations& from);
  Animations(Animations&& from) noexcept
    : Animations() {
    *this = ::std::move(from);
  }

  inline Animations& operator=(const Animations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animations& operator=(Animations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Animations& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animations* internal_default_instance() {
    return reinterpret_cast<const Animations*>(
               &_Animations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Animations& a, Animations& b) {
    a.Swap(&b);
  }
  inline void Swap(Animations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Animations>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Animations& from);
  void MergeFrom(const Animations& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Animations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Animations";
  }
  protected:
  explicit Animations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Animations_keys keys;
  typedef Animations_Channel Channel;

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 4,
    kNameFieldNumber = 1,
    kTickspersecondFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // repeated .model.Animations.Channel channels = 4;
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  ::model::Animations_Channel* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_Channel >*
      mutable_channels();
  private:
  const ::model::Animations_Channel& _internal_channels(int index) const;
  ::model::Animations_Channel* _internal_add_channels();
  public:
  const ::model::Animations_Channel& channels(int index) const;
  ::model::Animations_Channel* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_Channel >&
      channels() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 tickspersecond = 2;
  bool has_tickspersecond() const;
  private:
  bool _internal_has_tickspersecond() const;
  public:
  void clear_tickspersecond();
  int32_t tickspersecond() const;
  void set_tickspersecond(int32_t value);
  private:
  int32_t _internal_tickspersecond() const;
  void _internal_set_tickspersecond(int32_t value);
  public:

  // optional int32 duration = 3;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:model.Animations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_Channel > channels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t tickspersecond_;
  int32_t duration_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:model.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "model.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeshesFieldNumber = 3,
    kMaterialsFieldNumber = 4,
    kAnimationsFieldNumber = 5,
    kRootnodeFieldNumber = 1,
    kFlagsFieldNumber = 2,
  };
  // repeated .model.Meshes meshes = 3;
  int meshes_size() const;
  private:
  int _internal_meshes_size() const;
  public:
  void clear_meshes();
  ::model::Meshes* mutable_meshes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes >*
      mutable_meshes();
  private:
  const ::model::Meshes& _internal_meshes(int index) const;
  ::model::Meshes* _internal_add_meshes();
  public:
  const ::model::Meshes& meshes(int index) const;
  ::model::Meshes* add_meshes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes >&
      meshes() const;

  // repeated .model.Materials materials = 4;
  int materials_size() const;
  private:
  int _internal_materials_size() const;
  public:
  void clear_materials();
  ::model::Materials* mutable_materials(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials >*
      mutable_materials();
  private:
  const ::model::Materials& _internal_materials(int index) const;
  ::model::Materials* _internal_add_materials();
  public:
  const ::model::Materials& materials(int index) const;
  ::model::Materials* add_materials();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials >&
      materials() const;

  // repeated .model.Animations animations = 5;
  int animations_size() const;
  private:
  int _internal_animations_size() const;
  public:
  void clear_animations();
  ::model::Animations* mutable_animations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations >*
      mutable_animations();
  private:
  const ::model::Animations& _internal_animations(int index) const;
  ::model::Animations* _internal_add_animations();
  public:
  const ::model::Animations& animations(int index) const;
  ::model::Animations* add_animations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations >&
      animations() const;

  // optional .model.Node rootnode = 1;
  bool has_rootnode() const;
  private:
  bool _internal_has_rootnode() const;
  public:
  void clear_rootnode();
  const ::model::Node& rootnode() const;
  PROTOBUF_NODISCARD ::model::Node* release_rootnode();
  ::model::Node* mutable_rootnode();
  void set_allocated_rootnode(::model::Node* rootnode);
  private:
  const ::model::Node& _internal_rootnode() const;
  ::model::Node* _internal_mutable_rootnode();
  public:
  void unsafe_arena_set_allocated_rootnode(
      ::model::Node* rootnode);
  ::model::Node* unsafe_arena_release_rootnode();

  // optional int32 flags = 2;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:model.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes > meshes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials > materials_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations > animations_;
  ::model::Node* rootnode_;
  int32_t flags_;
  friend struct ::TableStruct_model_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Node

// optional string name = 1;
inline bool Node::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Node::has_name() const {
  return _internal_has_name();
}
inline void Node::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:model.Node.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:model.Node.name)
}
inline std::string* Node::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:model.Node.name)
  return _s;
}
inline const std::string& Node::_internal_name() const {
  return name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:model.Node.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:model.Node.name)
}

// repeated float transformation = 2;
inline int Node::_internal_transformation_size() const {
  return transformation_.size();
}
inline int Node::transformation_size() const {
  return _internal_transformation_size();
}
inline void Node::clear_transformation() {
  transformation_.Clear();
}
inline float Node::_internal_transformation(int index) const {
  return transformation_.Get(index);
}
inline float Node::transformation(int index) const {
  // @@protoc_insertion_point(field_get:model.Node.transformation)
  return _internal_transformation(index);
}
inline void Node::set_transformation(int index, float value) {
  transformation_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Node.transformation)
}
inline void Node::_internal_add_transformation(float value) {
  transformation_.Add(value);
}
inline void Node::add_transformation(float value) {
  _internal_add_transformation(value);
  // @@protoc_insertion_point(field_add:model.Node.transformation)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Node::_internal_transformation() const {
  return transformation_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Node::transformation() const {
  // @@protoc_insertion_point(field_list:model.Node.transformation)
  return _internal_transformation();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Node::_internal_mutable_transformation() {
  return &transformation_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Node::mutable_transformation() {
  // @@protoc_insertion_point(field_mutable_list:model.Node.transformation)
  return _internal_mutable_transformation();
}

// repeated int32 meshes = 3;
inline int Node::_internal_meshes_size() const {
  return meshes_.size();
}
inline int Node::meshes_size() const {
  return _internal_meshes_size();
}
inline void Node::clear_meshes() {
  meshes_.Clear();
}
inline int32_t Node::_internal_meshes(int index) const {
  return meshes_.Get(index);
}
inline int32_t Node::meshes(int index) const {
  // @@protoc_insertion_point(field_get:model.Node.meshes)
  return _internal_meshes(index);
}
inline void Node::set_meshes(int index, int32_t value) {
  meshes_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Node.meshes)
}
inline void Node::_internal_add_meshes(int32_t value) {
  meshes_.Add(value);
}
inline void Node::add_meshes(int32_t value) {
  _internal_add_meshes(value);
  // @@protoc_insertion_point(field_add:model.Node.meshes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Node::_internal_meshes() const {
  return meshes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Node::meshes() const {
  // @@protoc_insertion_point(field_list:model.Node.meshes)
  return _internal_meshes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Node::_internal_mutable_meshes() {
  return &meshes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Node::mutable_meshes() {
  // @@protoc_insertion_point(field_mutable_list:model.Node.meshes)
  return _internal_mutable_meshes();
}

// repeated .model.Node children = 4;
inline int Node::_internal_children_size() const {
  return children_.size();
}
inline int Node::children_size() const {
  return _internal_children_size();
}
inline void Node::clear_children() {
  children_.Clear();
}
inline ::model::Node* Node::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:model.Node.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Node >*
Node::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:model.Node.children)
  return &children_;
}
inline const ::model::Node& Node::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::model::Node& Node::children(int index) const {
  // @@protoc_insertion_point(field_get:model.Node.children)
  return _internal_children(index);
}
inline ::model::Node* Node::_internal_add_children() {
  return children_.Add();
}
inline ::model::Node* Node::add_children() {
  ::model::Node* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:model.Node.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Node >&
Node::children() const {
  // @@protoc_insertion_point(field_list:model.Node.children)
  return children_;
}

// -------------------------------------------------------------------

// Meshes_TexturecoordsEntry

// repeated float data = 1;
inline int Meshes_TexturecoordsEntry::_internal_data_size() const {
  return data_.size();
}
inline int Meshes_TexturecoordsEntry::data_size() const {
  return _internal_data_size();
}
inline void Meshes_TexturecoordsEntry::clear_data() {
  data_.Clear();
}
inline float Meshes_TexturecoordsEntry::_internal_data(int index) const {
  return data_.Get(index);
}
inline float Meshes_TexturecoordsEntry::data(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.TexturecoordsEntry.data)
  return _internal_data(index);
}
inline void Meshes_TexturecoordsEntry::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Meshes.TexturecoordsEntry.data)
}
inline void Meshes_TexturecoordsEntry::_internal_add_data(float value) {
  data_.Add(value);
}
inline void Meshes_TexturecoordsEntry::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:model.Meshes.TexturecoordsEntry.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes_TexturecoordsEntry::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes_TexturecoordsEntry::data() const {
  // @@protoc_insertion_point(field_list:model.Meshes.TexturecoordsEntry.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes_TexturecoordsEntry::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes_TexturecoordsEntry::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.TexturecoordsEntry.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Meshes_BonesWeight

// repeated int32 data = 1;
inline int Meshes_BonesWeight::_internal_data_size() const {
  return data_.size();
}
inline int Meshes_BonesWeight::data_size() const {
  return _internal_data_size();
}
inline void Meshes_BonesWeight::clear_data() {
  data_.Clear();
}
inline int32_t Meshes_BonesWeight::_internal_data(int index) const {
  return data_.Get(index);
}
inline int32_t Meshes_BonesWeight::data(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.BonesWeight.data)
  return _internal_data(index);
}
inline void Meshes_BonesWeight::set_data(int index, int32_t value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Meshes.BonesWeight.data)
}
inline void Meshes_BonesWeight::_internal_add_data(int32_t value) {
  data_.Add(value);
}
inline void Meshes_BonesWeight::add_data(int32_t value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:model.Meshes.BonesWeight.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Meshes_BonesWeight::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Meshes_BonesWeight::data() const {
  // @@protoc_insertion_point(field_list:model.Meshes.BonesWeight.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Meshes_BonesWeight::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Meshes_BonesWeight::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.BonesWeight.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Meshes_BonesEntry

// optional string name = 1;
inline bool Meshes_BonesEntry::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Meshes_BonesEntry::has_name() const {
  return _internal_has_name();
}
inline void Meshes_BonesEntry::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Meshes_BonesEntry::name() const {
  // @@protoc_insertion_point(field_get:model.Meshes.BonesEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Meshes_BonesEntry::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:model.Meshes.BonesEntry.name)
}
inline std::string* Meshes_BonesEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:model.Meshes.BonesEntry.name)
  return _s;
}
inline const std::string& Meshes_BonesEntry::_internal_name() const {
  return name_.Get();
}
inline void Meshes_BonesEntry::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Meshes_BonesEntry::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Meshes_BonesEntry::release_name() {
  // @@protoc_insertion_point(field_release:model.Meshes.BonesEntry.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Meshes_BonesEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:model.Meshes.BonesEntry.name)
}

// repeated float offsetmatrix = 2;
inline int Meshes_BonesEntry::_internal_offsetmatrix_size() const {
  return offsetmatrix_.size();
}
inline int Meshes_BonesEntry::offsetmatrix_size() const {
  return _internal_offsetmatrix_size();
}
inline void Meshes_BonesEntry::clear_offsetmatrix() {
  offsetmatrix_.Clear();
}
inline float Meshes_BonesEntry::_internal_offsetmatrix(int index) const {
  return offsetmatrix_.Get(index);
}
inline float Meshes_BonesEntry::offsetmatrix(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.BonesEntry.offsetmatrix)
  return _internal_offsetmatrix(index);
}
inline void Meshes_BonesEntry::set_offsetmatrix(int index, float value) {
  offsetmatrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Meshes.BonesEntry.offsetmatrix)
}
inline void Meshes_BonesEntry::_internal_add_offsetmatrix(float value) {
  offsetmatrix_.Add(value);
}
inline void Meshes_BonesEntry::add_offsetmatrix(float value) {
  _internal_add_offsetmatrix(value);
  // @@protoc_insertion_point(field_add:model.Meshes.BonesEntry.offsetmatrix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes_BonesEntry::_internal_offsetmatrix() const {
  return offsetmatrix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes_BonesEntry::offsetmatrix() const {
  // @@protoc_insertion_point(field_list:model.Meshes.BonesEntry.offsetmatrix)
  return _internal_offsetmatrix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes_BonesEntry::_internal_mutable_offsetmatrix() {
  return &offsetmatrix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes_BonesEntry::mutable_offsetmatrix() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.BonesEntry.offsetmatrix)
  return _internal_mutable_offsetmatrix();
}

// repeated .model.Meshes.BonesWeight weights = 3;
inline int Meshes_BonesEntry::_internal_weights_size() const {
  return weights_.size();
}
inline int Meshes_BonesEntry::weights_size() const {
  return _internal_weights_size();
}
inline void Meshes_BonesEntry::clear_weights() {
  weights_.Clear();
}
inline ::model::Meshes_BonesWeight* Meshes_BonesEntry::mutable_weights(int index) {
  // @@protoc_insertion_point(field_mutable:model.Meshes.BonesEntry.weights)
  return weights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesWeight >*
Meshes_BonesEntry::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.BonesEntry.weights)
  return &weights_;
}
inline const ::model::Meshes_BonesWeight& Meshes_BonesEntry::_internal_weights(int index) const {
  return weights_.Get(index);
}
inline const ::model::Meshes_BonesWeight& Meshes_BonesEntry::weights(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.BonesEntry.weights)
  return _internal_weights(index);
}
inline ::model::Meshes_BonesWeight* Meshes_BonesEntry::_internal_add_weights() {
  return weights_.Add();
}
inline ::model::Meshes_BonesWeight* Meshes_BonesEntry::add_weights() {
  ::model::Meshes_BonesWeight* _add = _internal_add_weights();
  // @@protoc_insertion_point(field_add:model.Meshes.BonesEntry.weights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesWeight >&
Meshes_BonesEntry::weights() const {
  // @@protoc_insertion_point(field_list:model.Meshes.BonesEntry.weights)
  return weights_;
}

// -------------------------------------------------------------------

// Meshes_FaceEntry

// repeated int32 data = 1;
inline int Meshes_FaceEntry::_internal_data_size() const {
  return data_.size();
}
inline int Meshes_FaceEntry::data_size() const {
  return _internal_data_size();
}
inline void Meshes_FaceEntry::clear_data() {
  data_.Clear();
}
inline int32_t Meshes_FaceEntry::_internal_data(int index) const {
  return data_.Get(index);
}
inline int32_t Meshes_FaceEntry::data(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.FaceEntry.data)
  return _internal_data(index);
}
inline void Meshes_FaceEntry::set_data(int index, int32_t value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Meshes.FaceEntry.data)
}
inline void Meshes_FaceEntry::_internal_add_data(int32_t value) {
  data_.Add(value);
}
inline void Meshes_FaceEntry::add_data(int32_t value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:model.Meshes.FaceEntry.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Meshes_FaceEntry::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Meshes_FaceEntry::data() const {
  // @@protoc_insertion_point(field_list:model.Meshes.FaceEntry.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Meshes_FaceEntry::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Meshes_FaceEntry::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.FaceEntry.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Meshes

// optional string name = 1;
inline bool Meshes::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Meshes::has_name() const {
  return _internal_has_name();
}
inline void Meshes::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Meshes::name() const {
  // @@protoc_insertion_point(field_get:model.Meshes.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Meshes::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:model.Meshes.name)
}
inline std::string* Meshes::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:model.Meshes.name)
  return _s;
}
inline const std::string& Meshes::_internal_name() const {
  return name_.Get();
}
inline void Meshes::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Meshes::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Meshes::release_name() {
  // @@protoc_insertion_point(field_release:model.Meshes.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Meshes::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:model.Meshes.name)
}

// optional int32 materialindex = 2;
inline bool Meshes::_internal_has_materialindex() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Meshes::has_materialindex() const {
  return _internal_has_materialindex();
}
inline void Meshes::clear_materialindex() {
  materialindex_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Meshes::_internal_materialindex() const {
  return materialindex_;
}
inline int32_t Meshes::materialindex() const {
  // @@protoc_insertion_point(field_get:model.Meshes.materialindex)
  return _internal_materialindex();
}
inline void Meshes::_internal_set_materialindex(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  materialindex_ = value;
}
inline void Meshes::set_materialindex(int32_t value) {
  _internal_set_materialindex(value);
  // @@protoc_insertion_point(field_set:model.Meshes.materialindex)
}

// optional int32 primitivetypes = 3;
inline bool Meshes::_internal_has_primitivetypes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Meshes::has_primitivetypes() const {
  return _internal_has_primitivetypes();
}
inline void Meshes::clear_primitivetypes() {
  primitivetypes_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Meshes::_internal_primitivetypes() const {
  return primitivetypes_;
}
inline int32_t Meshes::primitivetypes() const {
  // @@protoc_insertion_point(field_get:model.Meshes.primitivetypes)
  return _internal_primitivetypes();
}
inline void Meshes::_internal_set_primitivetypes(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  primitivetypes_ = value;
}
inline void Meshes::set_primitivetypes(int32_t value) {
  _internal_set_primitivetypes(value);
  // @@protoc_insertion_point(field_set:model.Meshes.primitivetypes)
}

// repeated float vertices = 4;
inline int Meshes::_internal_vertices_size() const {
  return vertices_.size();
}
inline int Meshes::vertices_size() const {
  return _internal_vertices_size();
}
inline void Meshes::clear_vertices() {
  vertices_.Clear();
}
inline float Meshes::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline float Meshes::vertices(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.vertices)
  return _internal_vertices(index);
}
inline void Meshes::set_vertices(int index, float value) {
  vertices_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Meshes.vertices)
}
inline void Meshes::_internal_add_vertices(float value) {
  vertices_.Add(value);
}
inline void Meshes::add_vertices(float value) {
  _internal_add_vertices(value);
  // @@protoc_insertion_point(field_add:model.Meshes.vertices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes::_internal_vertices() const {
  return vertices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes::vertices() const {
  // @@protoc_insertion_point(field_list:model.Meshes.vertices)
  return _internal_vertices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes::_internal_mutable_vertices() {
  return &vertices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.vertices)
  return _internal_mutable_vertices();
}

// repeated float normals = 5;
inline int Meshes::_internal_normals_size() const {
  return normals_.size();
}
inline int Meshes::normals_size() const {
  return _internal_normals_size();
}
inline void Meshes::clear_normals() {
  normals_.Clear();
}
inline float Meshes::_internal_normals(int index) const {
  return normals_.Get(index);
}
inline float Meshes::normals(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.normals)
  return _internal_normals(index);
}
inline void Meshes::set_normals(int index, float value) {
  normals_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Meshes.normals)
}
inline void Meshes::_internal_add_normals(float value) {
  normals_.Add(value);
}
inline void Meshes::add_normals(float value) {
  _internal_add_normals(value);
  // @@protoc_insertion_point(field_add:model.Meshes.normals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes::_internal_normals() const {
  return normals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Meshes::normals() const {
  // @@protoc_insertion_point(field_list:model.Meshes.normals)
  return _internal_normals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes::_internal_mutable_normals() {
  return &normals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Meshes::mutable_normals() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.normals)
  return _internal_mutable_normals();
}

// repeated int32 numuvcomponents = 6;
inline int Meshes::_internal_numuvcomponents_size() const {
  return numuvcomponents_.size();
}
inline int Meshes::numuvcomponents_size() const {
  return _internal_numuvcomponents_size();
}
inline void Meshes::clear_numuvcomponents() {
  numuvcomponents_.Clear();
}
inline int32_t Meshes::_internal_numuvcomponents(int index) const {
  return numuvcomponents_.Get(index);
}
inline int32_t Meshes::numuvcomponents(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.numuvcomponents)
  return _internal_numuvcomponents(index);
}
inline void Meshes::set_numuvcomponents(int index, int32_t value) {
  numuvcomponents_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Meshes.numuvcomponents)
}
inline void Meshes::_internal_add_numuvcomponents(int32_t value) {
  numuvcomponents_.Add(value);
}
inline void Meshes::add_numuvcomponents(int32_t value) {
  _internal_add_numuvcomponents(value);
  // @@protoc_insertion_point(field_add:model.Meshes.numuvcomponents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Meshes::_internal_numuvcomponents() const {
  return numuvcomponents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Meshes::numuvcomponents() const {
  // @@protoc_insertion_point(field_list:model.Meshes.numuvcomponents)
  return _internal_numuvcomponents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Meshes::_internal_mutable_numuvcomponents() {
  return &numuvcomponents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Meshes::mutable_numuvcomponents() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.numuvcomponents)
  return _internal_mutable_numuvcomponents();
}

// repeated .model.Meshes.TexturecoordsEntry texturecoords = 7;
inline int Meshes::_internal_texturecoords_size() const {
  return texturecoords_.size();
}
inline int Meshes::texturecoords_size() const {
  return _internal_texturecoords_size();
}
inline void Meshes::clear_texturecoords() {
  texturecoords_.Clear();
}
inline ::model::Meshes_TexturecoordsEntry* Meshes::mutable_texturecoords(int index) {
  // @@protoc_insertion_point(field_mutable:model.Meshes.texturecoords)
  return texturecoords_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_TexturecoordsEntry >*
Meshes::mutable_texturecoords() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.texturecoords)
  return &texturecoords_;
}
inline const ::model::Meshes_TexturecoordsEntry& Meshes::_internal_texturecoords(int index) const {
  return texturecoords_.Get(index);
}
inline const ::model::Meshes_TexturecoordsEntry& Meshes::texturecoords(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.texturecoords)
  return _internal_texturecoords(index);
}
inline ::model::Meshes_TexturecoordsEntry* Meshes::_internal_add_texturecoords() {
  return texturecoords_.Add();
}
inline ::model::Meshes_TexturecoordsEntry* Meshes::add_texturecoords() {
  ::model::Meshes_TexturecoordsEntry* _add = _internal_add_texturecoords();
  // @@protoc_insertion_point(field_add:model.Meshes.texturecoords)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_TexturecoordsEntry >&
Meshes::texturecoords() const {
  // @@protoc_insertion_point(field_list:model.Meshes.texturecoords)
  return texturecoords_;
}

// repeated .model.Meshes.BonesEntry bones = 8;
inline int Meshes::_internal_bones_size() const {
  return bones_.size();
}
inline int Meshes::bones_size() const {
  return _internal_bones_size();
}
inline void Meshes::clear_bones() {
  bones_.Clear();
}
inline ::model::Meshes_BonesEntry* Meshes::mutable_bones(int index) {
  // @@protoc_insertion_point(field_mutable:model.Meshes.bones)
  return bones_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesEntry >*
Meshes::mutable_bones() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.bones)
  return &bones_;
}
inline const ::model::Meshes_BonesEntry& Meshes::_internal_bones(int index) const {
  return bones_.Get(index);
}
inline const ::model::Meshes_BonesEntry& Meshes::bones(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.bones)
  return _internal_bones(index);
}
inline ::model::Meshes_BonesEntry* Meshes::_internal_add_bones() {
  return bones_.Add();
}
inline ::model::Meshes_BonesEntry* Meshes::add_bones() {
  ::model::Meshes_BonesEntry* _add = _internal_add_bones();
  // @@protoc_insertion_point(field_add:model.Meshes.bones)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_BonesEntry >&
Meshes::bones() const {
  // @@protoc_insertion_point(field_list:model.Meshes.bones)
  return bones_;
}

// repeated .model.Meshes.FaceEntry faces = 9;
inline int Meshes::_internal_faces_size() const {
  return faces_.size();
}
inline int Meshes::faces_size() const {
  return _internal_faces_size();
}
inline void Meshes::clear_faces() {
  faces_.Clear();
}
inline ::model::Meshes_FaceEntry* Meshes::mutable_faces(int index) {
  // @@protoc_insertion_point(field_mutable:model.Meshes.faces)
  return faces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_FaceEntry >*
Meshes::mutable_faces() {
  // @@protoc_insertion_point(field_mutable_list:model.Meshes.faces)
  return &faces_;
}
inline const ::model::Meshes_FaceEntry& Meshes::_internal_faces(int index) const {
  return faces_.Get(index);
}
inline const ::model::Meshes_FaceEntry& Meshes::faces(int index) const {
  // @@protoc_insertion_point(field_get:model.Meshes.faces)
  return _internal_faces(index);
}
inline ::model::Meshes_FaceEntry* Meshes::_internal_add_faces() {
  return faces_.Add();
}
inline ::model::Meshes_FaceEntry* Meshes::add_faces() {
  ::model::Meshes_FaceEntry* _add = _internal_add_faces();
  // @@protoc_insertion_point(field_add:model.Meshes.faces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes_FaceEntry >&
Meshes::faces() const {
  // @@protoc_insertion_point(field_list:model.Meshes.faces)
  return faces_;
}

// -------------------------------------------------------------------

// Materials_PropertyEntry

// optional string key = 1;
inline bool Materials_PropertyEntry::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Materials_PropertyEntry::has_key() const {
  return _internal_has_key();
}
inline void Materials_PropertyEntry::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Materials_PropertyEntry::key() const {
  // @@protoc_insertion_point(field_get:model.Materials.PropertyEntry.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Materials_PropertyEntry::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:model.Materials.PropertyEntry.key)
}
inline std::string* Materials_PropertyEntry::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:model.Materials.PropertyEntry.key)
  return _s;
}
inline const std::string& Materials_PropertyEntry::_internal_key() const {
  return key_.Get();
}
inline void Materials_PropertyEntry::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* Materials_PropertyEntry::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* Materials_PropertyEntry::release_key() {
  // @@protoc_insertion_point(field_release:model.Materials.PropertyEntry.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Materials_PropertyEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:model.Materials.PropertyEntry.key)
}

// optional int32 semantic = 2;
inline bool Materials_PropertyEntry::_internal_has_semantic() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Materials_PropertyEntry::has_semantic() const {
  return _internal_has_semantic();
}
inline void Materials_PropertyEntry::clear_semantic() {
  semantic_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Materials_PropertyEntry::_internal_semantic() const {
  return semantic_;
}
inline int32_t Materials_PropertyEntry::semantic() const {
  // @@protoc_insertion_point(field_get:model.Materials.PropertyEntry.semantic)
  return _internal_semantic();
}
inline void Materials_PropertyEntry::_internal_set_semantic(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  semantic_ = value;
}
inline void Materials_PropertyEntry::set_semantic(int32_t value) {
  _internal_set_semantic(value);
  // @@protoc_insertion_point(field_set:model.Materials.PropertyEntry.semantic)
}

// optional int32 index = 3;
inline bool Materials_PropertyEntry::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Materials_PropertyEntry::has_index() const {
  return _internal_has_index();
}
inline void Materials_PropertyEntry::clear_index() {
  index_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t Materials_PropertyEntry::_internal_index() const {
  return index_;
}
inline int32_t Materials_PropertyEntry::index() const {
  // @@protoc_insertion_point(field_get:model.Materials.PropertyEntry.index)
  return _internal_index();
}
inline void Materials_PropertyEntry::_internal_set_index(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  index_ = value;
}
inline void Materials_PropertyEntry::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:model.Materials.PropertyEntry.index)
}

// optional int32 type = 4;
inline bool Materials_PropertyEntry::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Materials_PropertyEntry::has_type() const {
  return _internal_has_type();
}
inline void Materials_PropertyEntry::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t Materials_PropertyEntry::_internal_type() const {
  return type_;
}
inline int32_t Materials_PropertyEntry::type() const {
  // @@protoc_insertion_point(field_get:model.Materials.PropertyEntry.type)
  return _internal_type();
}
inline void Materials_PropertyEntry::_internal_set_type(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void Materials_PropertyEntry::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:model.Materials.PropertyEntry.type)
}

// repeated float farray = 5;
inline int Materials_PropertyEntry::_internal_farray_size() const {
  return farray_.size();
}
inline int Materials_PropertyEntry::farray_size() const {
  return _internal_farray_size();
}
inline void Materials_PropertyEntry::clear_farray() {
  farray_.Clear();
}
inline float Materials_PropertyEntry::_internal_farray(int index) const {
  return farray_.Get(index);
}
inline float Materials_PropertyEntry::farray(int index) const {
  // @@protoc_insertion_point(field_get:model.Materials.PropertyEntry.farray)
  return _internal_farray(index);
}
inline void Materials_PropertyEntry::set_farray(int index, float value) {
  farray_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Materials.PropertyEntry.farray)
}
inline void Materials_PropertyEntry::_internal_add_farray(float value) {
  farray_.Add(value);
}
inline void Materials_PropertyEntry::add_farray(float value) {
  _internal_add_farray(value);
  // @@protoc_insertion_point(field_add:model.Materials.PropertyEntry.farray)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Materials_PropertyEntry::_internal_farray() const {
  return farray_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Materials_PropertyEntry::farray() const {
  // @@protoc_insertion_point(field_list:model.Materials.PropertyEntry.farray)
  return _internal_farray();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Materials_PropertyEntry::_internal_mutable_farray() {
  return &farray_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Materials_PropertyEntry::mutable_farray() {
  // @@protoc_insertion_point(field_mutable_list:model.Materials.PropertyEntry.farray)
  return _internal_mutable_farray();
}

// optional float fvalue = 7;
inline bool Materials_PropertyEntry::_internal_has_fvalue() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Materials_PropertyEntry::has_fvalue() const {
  return _internal_has_fvalue();
}
inline void Materials_PropertyEntry::clear_fvalue() {
  fvalue_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Materials_PropertyEntry::_internal_fvalue() const {
  return fvalue_;
}
inline float Materials_PropertyEntry::fvalue() const {
  // @@protoc_insertion_point(field_get:model.Materials.PropertyEntry.fvalue)
  return _internal_fvalue();
}
inline void Materials_PropertyEntry::_internal_set_fvalue(float value) {
  _has_bits_[0] |= 0x00000020u;
  fvalue_ = value;
}
inline void Materials_PropertyEntry::set_fvalue(float value) {
  _internal_set_fvalue(value);
  // @@protoc_insertion_point(field_set:model.Materials.PropertyEntry.fvalue)
}

// optional string svalue = 9;
inline bool Materials_PropertyEntry::_internal_has_svalue() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Materials_PropertyEntry::has_svalue() const {
  return _internal_has_svalue();
}
inline void Materials_PropertyEntry::clear_svalue() {
  svalue_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Materials_PropertyEntry::svalue() const {
  // @@protoc_insertion_point(field_get:model.Materials.PropertyEntry.svalue)
  return _internal_svalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Materials_PropertyEntry::set_svalue(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 svalue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:model.Materials.PropertyEntry.svalue)
}
inline std::string* Materials_PropertyEntry::mutable_svalue() {
  std::string* _s = _internal_mutable_svalue();
  // @@protoc_insertion_point(field_mutable:model.Materials.PropertyEntry.svalue)
  return _s;
}
inline const std::string& Materials_PropertyEntry::_internal_svalue() const {
  return svalue_.Get();
}
inline void Materials_PropertyEntry::_internal_set_svalue(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  svalue_.Set(value, GetArenaForAllocation());
}
inline std::string* Materials_PropertyEntry::_internal_mutable_svalue() {
  _has_bits_[0] |= 0x00000002u;
  return svalue_.Mutable(GetArenaForAllocation());
}
inline std::string* Materials_PropertyEntry::release_svalue() {
  // @@protoc_insertion_point(field_release:model.Materials.PropertyEntry.svalue)
  if (!_internal_has_svalue()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = svalue_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (svalue_.IsDefault()) {
    svalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Materials_PropertyEntry::set_allocated_svalue(std::string* svalue) {
  if (svalue != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  svalue_.SetAllocated(svalue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (svalue_.IsDefault()) {
    svalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:model.Materials.PropertyEntry.svalue)
}

// -------------------------------------------------------------------

// Materials

// repeated .model.Materials.PropertyEntry properties = 1;
inline int Materials::_internal_properties_size() const {
  return properties_.size();
}
inline int Materials::properties_size() const {
  return _internal_properties_size();
}
inline void Materials::clear_properties() {
  properties_.Clear();
}
inline ::model::Materials_PropertyEntry* Materials::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:model.Materials.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials_PropertyEntry >*
Materials::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:model.Materials.properties)
  return &properties_;
}
inline const ::model::Materials_PropertyEntry& Materials::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::model::Materials_PropertyEntry& Materials::properties(int index) const {
  // @@protoc_insertion_point(field_get:model.Materials.properties)
  return _internal_properties(index);
}
inline ::model::Materials_PropertyEntry* Materials::_internal_add_properties() {
  return properties_.Add();
}
inline ::model::Materials_PropertyEntry* Materials::add_properties() {
  ::model::Materials_PropertyEntry* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:model.Materials.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials_PropertyEntry >&
Materials::properties() const {
  // @@protoc_insertion_point(field_list:model.Materials.properties)
  return properties_;
}

// -------------------------------------------------------------------

// Animations_keys

// optional int32 val1 = 1;
inline bool Animations_keys::_internal_has_val1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Animations_keys::has_val1() const {
  return _internal_has_val1();
}
inline void Animations_keys::clear_val1() {
  val1_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t Animations_keys::_internal_val1() const {
  return val1_;
}
inline int32_t Animations_keys::val1() const {
  // @@protoc_insertion_point(field_get:model.Animations.keys.val1)
  return _internal_val1();
}
inline void Animations_keys::_internal_set_val1(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  val1_ = value;
}
inline void Animations_keys::set_val1(int32_t value) {
  _internal_set_val1(value);
  // @@protoc_insertion_point(field_set:model.Animations.keys.val1)
}

// repeated float val2 = 2;
inline int Animations_keys::_internal_val2_size() const {
  return val2_.size();
}
inline int Animations_keys::val2_size() const {
  return _internal_val2_size();
}
inline void Animations_keys::clear_val2() {
  val2_.Clear();
}
inline float Animations_keys::_internal_val2(int index) const {
  return val2_.Get(index);
}
inline float Animations_keys::val2(int index) const {
  // @@protoc_insertion_point(field_get:model.Animations.keys.val2)
  return _internal_val2(index);
}
inline void Animations_keys::set_val2(int index, float value) {
  val2_.Set(index, value);
  // @@protoc_insertion_point(field_set:model.Animations.keys.val2)
}
inline void Animations_keys::_internal_add_val2(float value) {
  val2_.Add(value);
}
inline void Animations_keys::add_val2(float value) {
  _internal_add_val2(value);
  // @@protoc_insertion_point(field_add:model.Animations.keys.val2)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Animations_keys::_internal_val2() const {
  return val2_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Animations_keys::val2() const {
  // @@protoc_insertion_point(field_list:model.Animations.keys.val2)
  return _internal_val2();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Animations_keys::_internal_mutable_val2() {
  return &val2_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Animations_keys::mutable_val2() {
  // @@protoc_insertion_point(field_mutable_list:model.Animations.keys.val2)
  return _internal_mutable_val2();
}

// -------------------------------------------------------------------

// Animations_Channel

// optional string name = 1;
inline bool Animations_Channel::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Animations_Channel::has_name() const {
  return _internal_has_name();
}
inline void Animations_Channel::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Animations_Channel::name() const {
  // @@protoc_insertion_point(field_get:model.Animations.Channel.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Animations_Channel::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:model.Animations.Channel.name)
}
inline std::string* Animations_Channel::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:model.Animations.Channel.name)
  return _s;
}
inline const std::string& Animations_Channel::_internal_name() const {
  return name_.Get();
}
inline void Animations_Channel::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Animations_Channel::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Animations_Channel::release_name() {
  // @@protoc_insertion_point(field_release:model.Animations.Channel.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Animations_Channel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:model.Animations.Channel.name)
}

// optional int32 prestate = 2;
inline bool Animations_Channel::_internal_has_prestate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Animations_Channel::has_prestate() const {
  return _internal_has_prestate();
}
inline void Animations_Channel::clear_prestate() {
  prestate_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Animations_Channel::_internal_prestate() const {
  return prestate_;
}
inline int32_t Animations_Channel::prestate() const {
  // @@protoc_insertion_point(field_get:model.Animations.Channel.prestate)
  return _internal_prestate();
}
inline void Animations_Channel::_internal_set_prestate(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  prestate_ = value;
}
inline void Animations_Channel::set_prestate(int32_t value) {
  _internal_set_prestate(value);
  // @@protoc_insertion_point(field_set:model.Animations.Channel.prestate)
}

// optional int32 poststate = 3;
inline bool Animations_Channel::_internal_has_poststate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Animations_Channel::has_poststate() const {
  return _internal_has_poststate();
}
inline void Animations_Channel::clear_poststate() {
  poststate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Animations_Channel::_internal_poststate() const {
  return poststate_;
}
inline int32_t Animations_Channel::poststate() const {
  // @@protoc_insertion_point(field_get:model.Animations.Channel.poststate)
  return _internal_poststate();
}
inline void Animations_Channel::_internal_set_poststate(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  poststate_ = value;
}
inline void Animations_Channel::set_poststate(int32_t value) {
  _internal_set_poststate(value);
  // @@protoc_insertion_point(field_set:model.Animations.Channel.poststate)
}

// repeated .model.Animations.keys positionkeys = 4;
inline int Animations_Channel::_internal_positionkeys_size() const {
  return positionkeys_.size();
}
inline int Animations_Channel::positionkeys_size() const {
  return _internal_positionkeys_size();
}
inline void Animations_Channel::clear_positionkeys() {
  positionkeys_.Clear();
}
inline ::model::Animations_keys* Animations_Channel::mutable_positionkeys(int index) {
  // @@protoc_insertion_point(field_mutable:model.Animations.Channel.positionkeys)
  return positionkeys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >*
Animations_Channel::mutable_positionkeys() {
  // @@protoc_insertion_point(field_mutable_list:model.Animations.Channel.positionkeys)
  return &positionkeys_;
}
inline const ::model::Animations_keys& Animations_Channel::_internal_positionkeys(int index) const {
  return positionkeys_.Get(index);
}
inline const ::model::Animations_keys& Animations_Channel::positionkeys(int index) const {
  // @@protoc_insertion_point(field_get:model.Animations.Channel.positionkeys)
  return _internal_positionkeys(index);
}
inline ::model::Animations_keys* Animations_Channel::_internal_add_positionkeys() {
  return positionkeys_.Add();
}
inline ::model::Animations_keys* Animations_Channel::add_positionkeys() {
  ::model::Animations_keys* _add = _internal_add_positionkeys();
  // @@protoc_insertion_point(field_add:model.Animations.Channel.positionkeys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >&
Animations_Channel::positionkeys() const {
  // @@protoc_insertion_point(field_list:model.Animations.Channel.positionkeys)
  return positionkeys_;
}

// repeated .model.Animations.keys rotationkeys = 5;
inline int Animations_Channel::_internal_rotationkeys_size() const {
  return rotationkeys_.size();
}
inline int Animations_Channel::rotationkeys_size() const {
  return _internal_rotationkeys_size();
}
inline void Animations_Channel::clear_rotationkeys() {
  rotationkeys_.Clear();
}
inline ::model::Animations_keys* Animations_Channel::mutable_rotationkeys(int index) {
  // @@protoc_insertion_point(field_mutable:model.Animations.Channel.rotationkeys)
  return rotationkeys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >*
Animations_Channel::mutable_rotationkeys() {
  // @@protoc_insertion_point(field_mutable_list:model.Animations.Channel.rotationkeys)
  return &rotationkeys_;
}
inline const ::model::Animations_keys& Animations_Channel::_internal_rotationkeys(int index) const {
  return rotationkeys_.Get(index);
}
inline const ::model::Animations_keys& Animations_Channel::rotationkeys(int index) const {
  // @@protoc_insertion_point(field_get:model.Animations.Channel.rotationkeys)
  return _internal_rotationkeys(index);
}
inline ::model::Animations_keys* Animations_Channel::_internal_add_rotationkeys() {
  return rotationkeys_.Add();
}
inline ::model::Animations_keys* Animations_Channel::add_rotationkeys() {
  ::model::Animations_keys* _add = _internal_add_rotationkeys();
  // @@protoc_insertion_point(field_add:model.Animations.Channel.rotationkeys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >&
Animations_Channel::rotationkeys() const {
  // @@protoc_insertion_point(field_list:model.Animations.Channel.rotationkeys)
  return rotationkeys_;
}

// repeated .model.Animations.keys scalingkeys = 6;
inline int Animations_Channel::_internal_scalingkeys_size() const {
  return scalingkeys_.size();
}
inline int Animations_Channel::scalingkeys_size() const {
  return _internal_scalingkeys_size();
}
inline void Animations_Channel::clear_scalingkeys() {
  scalingkeys_.Clear();
}
inline ::model::Animations_keys* Animations_Channel::mutable_scalingkeys(int index) {
  // @@protoc_insertion_point(field_mutable:model.Animations.Channel.scalingkeys)
  return scalingkeys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >*
Animations_Channel::mutable_scalingkeys() {
  // @@protoc_insertion_point(field_mutable_list:model.Animations.Channel.scalingkeys)
  return &scalingkeys_;
}
inline const ::model::Animations_keys& Animations_Channel::_internal_scalingkeys(int index) const {
  return scalingkeys_.Get(index);
}
inline const ::model::Animations_keys& Animations_Channel::scalingkeys(int index) const {
  // @@protoc_insertion_point(field_get:model.Animations.Channel.scalingkeys)
  return _internal_scalingkeys(index);
}
inline ::model::Animations_keys* Animations_Channel::_internal_add_scalingkeys() {
  return scalingkeys_.Add();
}
inline ::model::Animations_keys* Animations_Channel::add_scalingkeys() {
  ::model::Animations_keys* _add = _internal_add_scalingkeys();
  // @@protoc_insertion_point(field_add:model.Animations.Channel.scalingkeys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_keys >&
Animations_Channel::scalingkeys() const {
  // @@protoc_insertion_point(field_list:model.Animations.Channel.scalingkeys)
  return scalingkeys_;
}

// -------------------------------------------------------------------

// Animations

// optional string name = 1;
inline bool Animations::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Animations::has_name() const {
  return _internal_has_name();
}
inline void Animations::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Animations::name() const {
  // @@protoc_insertion_point(field_get:model.Animations.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Animations::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:model.Animations.name)
}
inline std::string* Animations::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:model.Animations.name)
  return _s;
}
inline const std::string& Animations::_internal_name() const {
  return name_.Get();
}
inline void Animations::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Animations::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Animations::release_name() {
  // @@protoc_insertion_point(field_release:model.Animations.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Animations::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:model.Animations.name)
}

// optional int32 tickspersecond = 2;
inline bool Animations::_internal_has_tickspersecond() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Animations::has_tickspersecond() const {
  return _internal_has_tickspersecond();
}
inline void Animations::clear_tickspersecond() {
  tickspersecond_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Animations::_internal_tickspersecond() const {
  return tickspersecond_;
}
inline int32_t Animations::tickspersecond() const {
  // @@protoc_insertion_point(field_get:model.Animations.tickspersecond)
  return _internal_tickspersecond();
}
inline void Animations::_internal_set_tickspersecond(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  tickspersecond_ = value;
}
inline void Animations::set_tickspersecond(int32_t value) {
  _internal_set_tickspersecond(value);
  // @@protoc_insertion_point(field_set:model.Animations.tickspersecond)
}

// optional int32 duration = 3;
inline bool Animations::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Animations::has_duration() const {
  return _internal_has_duration();
}
inline void Animations::clear_duration() {
  duration_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Animations::_internal_duration() const {
  return duration_;
}
inline int32_t Animations::duration() const {
  // @@protoc_insertion_point(field_get:model.Animations.duration)
  return _internal_duration();
}
inline void Animations::_internal_set_duration(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  duration_ = value;
}
inline void Animations::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:model.Animations.duration)
}

// repeated .model.Animations.Channel channels = 4;
inline int Animations::_internal_channels_size() const {
  return channels_.size();
}
inline int Animations::channels_size() const {
  return _internal_channels_size();
}
inline void Animations::clear_channels() {
  channels_.Clear();
}
inline ::model::Animations_Channel* Animations::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:model.Animations.channels)
  return channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_Channel >*
Animations::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:model.Animations.channels)
  return &channels_;
}
inline const ::model::Animations_Channel& Animations::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline const ::model::Animations_Channel& Animations::channels(int index) const {
  // @@protoc_insertion_point(field_get:model.Animations.channels)
  return _internal_channels(index);
}
inline ::model::Animations_Channel* Animations::_internal_add_channels() {
  return channels_.Add();
}
inline ::model::Animations_Channel* Animations::add_channels() {
  ::model::Animations_Channel* _add = _internal_add_channels();
  // @@protoc_insertion_point(field_add:model.Animations.channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations_Channel >&
Animations::channels() const {
  // @@protoc_insertion_point(field_list:model.Animations.channels)
  return channels_;
}

// -------------------------------------------------------------------

// Model

// optional .model.Node rootnode = 1;
inline bool Model::_internal_has_rootnode() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rootnode_ != nullptr);
  return value;
}
inline bool Model::has_rootnode() const {
  return _internal_has_rootnode();
}
inline void Model::clear_rootnode() {
  if (rootnode_ != nullptr) rootnode_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::model::Node& Model::_internal_rootnode() const {
  const ::model::Node* p = rootnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::model::Node&>(
      ::model::_Node_default_instance_);
}
inline const ::model::Node& Model::rootnode() const {
  // @@protoc_insertion_point(field_get:model.Model.rootnode)
  return _internal_rootnode();
}
inline void Model::unsafe_arena_set_allocated_rootnode(
    ::model::Node* rootnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rootnode_);
  }
  rootnode_ = rootnode;
  if (rootnode) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:model.Model.rootnode)
}
inline ::model::Node* Model::release_rootnode() {
  _has_bits_[0] &= ~0x00000001u;
  ::model::Node* temp = rootnode_;
  rootnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::model::Node* Model::unsafe_arena_release_rootnode() {
  // @@protoc_insertion_point(field_release:model.Model.rootnode)
  _has_bits_[0] &= ~0x00000001u;
  ::model::Node* temp = rootnode_;
  rootnode_ = nullptr;
  return temp;
}
inline ::model::Node* Model::_internal_mutable_rootnode() {
  _has_bits_[0] |= 0x00000001u;
  if (rootnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::model::Node>(GetArenaForAllocation());
    rootnode_ = p;
  }
  return rootnode_;
}
inline ::model::Node* Model::mutable_rootnode() {
  ::model::Node* _msg = _internal_mutable_rootnode();
  // @@protoc_insertion_point(field_mutable:model.Model.rootnode)
  return _msg;
}
inline void Model::set_allocated_rootnode(::model::Node* rootnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rootnode_;
  }
  if (rootnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rootnode);
    if (message_arena != submessage_arena) {
      rootnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rootnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rootnode_ = rootnode;
  // @@protoc_insertion_point(field_set_allocated:model.Model.rootnode)
}

// optional int32 flags = 2;
inline bool Model::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Model::has_flags() const {
  return _internal_has_flags();
}
inline void Model::clear_flags() {
  flags_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Model::_internal_flags() const {
  return flags_;
}
inline int32_t Model::flags() const {
  // @@protoc_insertion_point(field_get:model.Model.flags)
  return _internal_flags();
}
inline void Model::_internal_set_flags(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  flags_ = value;
}
inline void Model::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:model.Model.flags)
}

// repeated .model.Meshes meshes = 3;
inline int Model::_internal_meshes_size() const {
  return meshes_.size();
}
inline int Model::meshes_size() const {
  return _internal_meshes_size();
}
inline void Model::clear_meshes() {
  meshes_.Clear();
}
inline ::model::Meshes* Model::mutable_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:model.Model.meshes)
  return meshes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes >*
Model::mutable_meshes() {
  // @@protoc_insertion_point(field_mutable_list:model.Model.meshes)
  return &meshes_;
}
inline const ::model::Meshes& Model::_internal_meshes(int index) const {
  return meshes_.Get(index);
}
inline const ::model::Meshes& Model::meshes(int index) const {
  // @@protoc_insertion_point(field_get:model.Model.meshes)
  return _internal_meshes(index);
}
inline ::model::Meshes* Model::_internal_add_meshes() {
  return meshes_.Add();
}
inline ::model::Meshes* Model::add_meshes() {
  ::model::Meshes* _add = _internal_add_meshes();
  // @@protoc_insertion_point(field_add:model.Model.meshes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Meshes >&
Model::meshes() const {
  // @@protoc_insertion_point(field_list:model.Model.meshes)
  return meshes_;
}

// repeated .model.Materials materials = 4;
inline int Model::_internal_materials_size() const {
  return materials_.size();
}
inline int Model::materials_size() const {
  return _internal_materials_size();
}
inline void Model::clear_materials() {
  materials_.Clear();
}
inline ::model::Materials* Model::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:model.Model.materials)
  return materials_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials >*
Model::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:model.Model.materials)
  return &materials_;
}
inline const ::model::Materials& Model::_internal_materials(int index) const {
  return materials_.Get(index);
}
inline const ::model::Materials& Model::materials(int index) const {
  // @@protoc_insertion_point(field_get:model.Model.materials)
  return _internal_materials(index);
}
inline ::model::Materials* Model::_internal_add_materials() {
  return materials_.Add();
}
inline ::model::Materials* Model::add_materials() {
  ::model::Materials* _add = _internal_add_materials();
  // @@protoc_insertion_point(field_add:model.Model.materials)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Materials >&
Model::materials() const {
  // @@protoc_insertion_point(field_list:model.Model.materials)
  return materials_;
}

// repeated .model.Animations animations = 5;
inline int Model::_internal_animations_size() const {
  return animations_.size();
}
inline int Model::animations_size() const {
  return _internal_animations_size();
}
inline void Model::clear_animations() {
  animations_.Clear();
}
inline ::model::Animations* Model::mutable_animations(int index) {
  // @@protoc_insertion_point(field_mutable:model.Model.animations)
  return animations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations >*
Model::mutable_animations() {
  // @@protoc_insertion_point(field_mutable_list:model.Model.animations)
  return &animations_;
}
inline const ::model::Animations& Model::_internal_animations(int index) const {
  return animations_.Get(index);
}
inline const ::model::Animations& Model::animations(int index) const {
  // @@protoc_insertion_point(field_get:model.Model.animations)
  return _internal_animations(index);
}
inline ::model::Animations* Model::_internal_add_animations() {
  return animations_.Add();
}
inline ::model::Animations* Model::add_animations() {
  ::model::Animations* _add = _internal_add_animations();
  // @@protoc_insertion_point(field_add:model.Model.animations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::model::Animations >&
Model::animations() const {
  // @@protoc_insertion_point(field_list:model.Model.animations)
  return animations_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_model_2eproto
