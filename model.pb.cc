// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model.proto

#include "model.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace model {
PROTOBUF_CONSTEXPR Node::Node(
    ::_pbi::ConstantInitialized)
  : transformation_()
  , meshes_()
  , children_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeDefaultTypeInternal _Node_default_instance_;
PROTOBUF_CONSTEXPR Meshes_TexturecoordsEntry::Meshes_TexturecoordsEntry(
    ::_pbi::ConstantInitialized)
  : data_(){}
struct Meshes_TexturecoordsEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Meshes_TexturecoordsEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Meshes_TexturecoordsEntryDefaultTypeInternal() {}
  union {
    Meshes_TexturecoordsEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Meshes_TexturecoordsEntryDefaultTypeInternal _Meshes_TexturecoordsEntry_default_instance_;
PROTOBUF_CONSTEXPR Meshes_BonesWeight::Meshes_BonesWeight(
    ::_pbi::ConstantInitialized)
  : data_(){}
struct Meshes_BonesWeightDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Meshes_BonesWeightDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Meshes_BonesWeightDefaultTypeInternal() {}
  union {
    Meshes_BonesWeight _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Meshes_BonesWeightDefaultTypeInternal _Meshes_BonesWeight_default_instance_;
PROTOBUF_CONSTEXPR Meshes_BonesEntry::Meshes_BonesEntry(
    ::_pbi::ConstantInitialized)
  : offsetmatrix_()
  , weights_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct Meshes_BonesEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Meshes_BonesEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Meshes_BonesEntryDefaultTypeInternal() {}
  union {
    Meshes_BonesEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Meshes_BonesEntryDefaultTypeInternal _Meshes_BonesEntry_default_instance_;
PROTOBUF_CONSTEXPR Meshes_FaceEntry::Meshes_FaceEntry(
    ::_pbi::ConstantInitialized)
  : data_(){}
struct Meshes_FaceEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Meshes_FaceEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Meshes_FaceEntryDefaultTypeInternal() {}
  union {
    Meshes_FaceEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Meshes_FaceEntryDefaultTypeInternal _Meshes_FaceEntry_default_instance_;
PROTOBUF_CONSTEXPR Meshes::Meshes(
    ::_pbi::ConstantInitialized)
  : vertices_()
  , normals_()
  , numuvcomponents_()
  , texturecoords_()
  , bones_()
  , faces_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , materialindex_(0)
  , primitivetypes_(0){}
struct MeshesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MeshesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MeshesDefaultTypeInternal() {}
  union {
    Meshes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MeshesDefaultTypeInternal _Meshes_default_instance_;
PROTOBUF_CONSTEXPR Materials_PropertyEntry::Materials_PropertyEntry(
    ::_pbi::ConstantInitialized)
  : farray_()
  , key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , svalue_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , semantic_(0)
  , index_(0)
  , type_(0)
  , fvalue_(0){}
struct Materials_PropertyEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Materials_PropertyEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Materials_PropertyEntryDefaultTypeInternal() {}
  union {
    Materials_PropertyEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Materials_PropertyEntryDefaultTypeInternal _Materials_PropertyEntry_default_instance_;
PROTOBUF_CONSTEXPR Materials::Materials(
    ::_pbi::ConstantInitialized)
  : properties_(){}
struct MaterialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MaterialsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MaterialsDefaultTypeInternal() {}
  union {
    Materials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MaterialsDefaultTypeInternal _Materials_default_instance_;
PROTOBUF_CONSTEXPR Animations_keys::Animations_keys(
    ::_pbi::ConstantInitialized)
  : val2_()
  , val1_(0){}
struct Animations_keysDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Animations_keysDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Animations_keysDefaultTypeInternal() {}
  union {
    Animations_keys _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Animations_keysDefaultTypeInternal _Animations_keys_default_instance_;
PROTOBUF_CONSTEXPR Animations_Channel::Animations_Channel(
    ::_pbi::ConstantInitialized)
  : positionkeys_()
  , rotationkeys_()
  , scalingkeys_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , prestate_(0)
  , poststate_(0){}
struct Animations_ChannelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Animations_ChannelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Animations_ChannelDefaultTypeInternal() {}
  union {
    Animations_Channel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Animations_ChannelDefaultTypeInternal _Animations_Channel_default_instance_;
PROTOBUF_CONSTEXPR Animations::Animations(
    ::_pbi::ConstantInitialized)
  : channels_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tickspersecond_(0)
  , duration_(0){}
struct AnimationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnimationsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnimationsDefaultTypeInternal() {}
  union {
    Animations _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnimationsDefaultTypeInternal _Animations_default_instance_;
PROTOBUF_CONSTEXPR Model::Model(
    ::_pbi::ConstantInitialized)
  : meshes_()
  , materials_()
  , animations_()
  , rootnode_(nullptr)
  , flags_(0){}
struct ModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelDefaultTypeInternal() {}
  union {
    Model _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelDefaultTypeInternal _Model_default_instance_;
}  // namespace model
namespace model {

// ===================================================================

class Node::_Internal {
 public:
  using HasBits = decltype(std::declval<Node>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Node::Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  transformation_(arena),
  meshes_(arena),
  children_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Node)
}
Node::Node(const Node& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      transformation_(from.transformation_),
      meshes_(from.meshes_),
      children_(from.children_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:model.Node)
}

inline void Node::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Node::~Node() {
  // @@protoc_insertion_point(destructor:model.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void Node::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Node::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  transformation_.Clear();
  meshes_.Clear();
  children_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float transformation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_transformation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<21>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_transformation(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 meshes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_meshes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_meshes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Node children = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated float transformation = 2;
  for (int i = 0, n = this->_internal_transformation_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_transformation(i), target);
  }

  // repeated int32 meshes = 3;
  for (int i = 0, n = this->_internal_meshes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_meshes(i), target);
  }

  // repeated .model.Node children = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Node)
  return target;
}

size_t Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float transformation = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_transformation_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_transformation_size());
    total_size += data_size;
  }

  // repeated int32 meshes = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->meshes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_meshes_size());
    total_size += data_size;
  }

  // repeated .model.Node children = 4;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Node::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Node*>(
      &from));
}

void Node::MergeFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Node)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  transformation_.MergeFrom(from.transformation_);
  meshes_.MergeFrom(from.meshes_);
  children_.MergeFrom(from.children_);
  if (from._internal_has_name()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Node::CopyFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Node::IsInitialized() const {
  return true;
}

void Node::InternalSwap(Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  transformation_.InternalSwap(&other->transformation_);
  meshes_.InternalSwap(&other->meshes_);
  children_.InternalSwap(&other->children_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

std::string Node::GetTypeName() const {
  return "model.Node";
}


// ===================================================================

class Meshes_TexturecoordsEntry::_Internal {
 public:
};

Meshes_TexturecoordsEntry::Meshes_TexturecoordsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Meshes.TexturecoordsEntry)
}
Meshes_TexturecoordsEntry::Meshes_TexturecoordsEntry(const Meshes_TexturecoordsEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:model.Meshes.TexturecoordsEntry)
}

inline void Meshes_TexturecoordsEntry::SharedCtor() {
}

Meshes_TexturecoordsEntry::~Meshes_TexturecoordsEntry() {
  // @@protoc_insertion_point(destructor:model.Meshes.TexturecoordsEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Meshes_TexturecoordsEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Meshes_TexturecoordsEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Meshes_TexturecoordsEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Meshes.TexturecoordsEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Meshes_TexturecoordsEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Meshes_TexturecoordsEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Meshes.TexturecoordsEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_data(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Meshes.TexturecoordsEntry)
  return target;
}

size_t Meshes_TexturecoordsEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Meshes.TexturecoordsEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float data = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_data_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Meshes_TexturecoordsEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Meshes_TexturecoordsEntry*>(
      &from));
}

void Meshes_TexturecoordsEntry::MergeFrom(const Meshes_TexturecoordsEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Meshes.TexturecoordsEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Meshes_TexturecoordsEntry::CopyFrom(const Meshes_TexturecoordsEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Meshes.TexturecoordsEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meshes_TexturecoordsEntry::IsInitialized() const {
  return true;
}

void Meshes_TexturecoordsEntry::InternalSwap(Meshes_TexturecoordsEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
}

std::string Meshes_TexturecoordsEntry::GetTypeName() const {
  return "model.Meshes.TexturecoordsEntry";
}


// ===================================================================

class Meshes_BonesWeight::_Internal {
 public:
};

Meshes_BonesWeight::Meshes_BonesWeight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Meshes.BonesWeight)
}
Meshes_BonesWeight::Meshes_BonesWeight(const Meshes_BonesWeight& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:model.Meshes.BonesWeight)
}

inline void Meshes_BonesWeight::SharedCtor() {
}

Meshes_BonesWeight::~Meshes_BonesWeight() {
  // @@protoc_insertion_point(destructor:model.Meshes.BonesWeight)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Meshes_BonesWeight::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Meshes_BonesWeight::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Meshes_BonesWeight::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Meshes.BonesWeight)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Meshes_BonesWeight::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Meshes_BonesWeight::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Meshes.BonesWeight)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_data(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Meshes.BonesWeight)
  return target;
}

size_t Meshes_BonesWeight::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Meshes.BonesWeight)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 data = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->data_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_data_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Meshes_BonesWeight::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Meshes_BonesWeight*>(
      &from));
}

void Meshes_BonesWeight::MergeFrom(const Meshes_BonesWeight& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Meshes.BonesWeight)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Meshes_BonesWeight::CopyFrom(const Meshes_BonesWeight& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Meshes.BonesWeight)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meshes_BonesWeight::IsInitialized() const {
  return true;
}

void Meshes_BonesWeight::InternalSwap(Meshes_BonesWeight* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
}

std::string Meshes_BonesWeight::GetTypeName() const {
  return "model.Meshes.BonesWeight";
}


// ===================================================================

class Meshes_BonesEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<Meshes_BonesEntry>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Meshes_BonesEntry::Meshes_BonesEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  offsetmatrix_(arena),
  weights_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Meshes.BonesEntry)
}
Meshes_BonesEntry::Meshes_BonesEntry(const Meshes_BonesEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      offsetmatrix_(from.offsetmatrix_),
      weights_(from.weights_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:model.Meshes.BonesEntry)
}

inline void Meshes_BonesEntry::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Meshes_BonesEntry::~Meshes_BonesEntry() {
  // @@protoc_insertion_point(destructor:model.Meshes.BonesEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Meshes_BonesEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void Meshes_BonesEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Meshes_BonesEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Meshes.BonesEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  offsetmatrix_.Clear();
  weights_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Meshes_BonesEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float offsetmatrix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_offsetmatrix(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<21>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_offsetmatrix(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Meshes.BonesWeight weights = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_weights(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Meshes_BonesEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Meshes.BonesEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated float offsetmatrix = 2;
  for (int i = 0, n = this->_internal_offsetmatrix_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_offsetmatrix(i), target);
  }

  // repeated .model.Meshes.BonesWeight weights = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_weights_size()); i < n; i++) {
    const auto& repfield = this->_internal_weights(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Meshes.BonesEntry)
  return target;
}

size_t Meshes_BonesEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Meshes.BonesEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float offsetmatrix = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_offsetmatrix_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_offsetmatrix_size());
    total_size += data_size;
  }

  // repeated .model.Meshes.BonesWeight weights = 3;
  total_size += 1UL * this->_internal_weights_size();
  for (const auto& msg : this->weights_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Meshes_BonesEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Meshes_BonesEntry*>(
      &from));
}

void Meshes_BonesEntry::MergeFrom(const Meshes_BonesEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Meshes.BonesEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  offsetmatrix_.MergeFrom(from.offsetmatrix_);
  weights_.MergeFrom(from.weights_);
  if (from._internal_has_name()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Meshes_BonesEntry::CopyFrom(const Meshes_BonesEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Meshes.BonesEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meshes_BonesEntry::IsInitialized() const {
  return true;
}

void Meshes_BonesEntry::InternalSwap(Meshes_BonesEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  offsetmatrix_.InternalSwap(&other->offsetmatrix_);
  weights_.InternalSwap(&other->weights_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

std::string Meshes_BonesEntry::GetTypeName() const {
  return "model.Meshes.BonesEntry";
}


// ===================================================================

class Meshes_FaceEntry::_Internal {
 public:
};

Meshes_FaceEntry::Meshes_FaceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Meshes.FaceEntry)
}
Meshes_FaceEntry::Meshes_FaceEntry(const Meshes_FaceEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:model.Meshes.FaceEntry)
}

inline void Meshes_FaceEntry::SharedCtor() {
}

Meshes_FaceEntry::~Meshes_FaceEntry() {
  // @@protoc_insertion_point(destructor:model.Meshes.FaceEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Meshes_FaceEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Meshes_FaceEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Meshes_FaceEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Meshes.FaceEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Meshes_FaceEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Meshes_FaceEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Meshes.FaceEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_data(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Meshes.FaceEntry)
  return target;
}

size_t Meshes_FaceEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Meshes.FaceEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 data = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->data_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_data_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Meshes_FaceEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Meshes_FaceEntry*>(
      &from));
}

void Meshes_FaceEntry::MergeFrom(const Meshes_FaceEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Meshes.FaceEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Meshes_FaceEntry::CopyFrom(const Meshes_FaceEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Meshes.FaceEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meshes_FaceEntry::IsInitialized() const {
  return true;
}

void Meshes_FaceEntry::InternalSwap(Meshes_FaceEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
}

std::string Meshes_FaceEntry::GetTypeName() const {
  return "model.Meshes.FaceEntry";
}


// ===================================================================

class Meshes::_Internal {
 public:
  using HasBits = decltype(std::declval<Meshes>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_materialindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_primitivetypes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Meshes::Meshes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vertices_(arena),
  normals_(arena),
  numuvcomponents_(arena),
  texturecoords_(arena),
  bones_(arena),
  faces_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Meshes)
}
Meshes::Meshes(const Meshes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      vertices_(from.vertices_),
      normals_(from.normals_),
      numuvcomponents_(from.numuvcomponents_),
      texturecoords_(from.texturecoords_),
      bones_(from.bones_),
      faces_(from.faces_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&materialindex_, &from.materialindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&primitivetypes_) -
    reinterpret_cast<char*>(&materialindex_)) + sizeof(primitivetypes_));
  // @@protoc_insertion_point(copy_constructor:model.Meshes)
}

inline void Meshes::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&materialindex_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&primitivetypes_) -
    reinterpret_cast<char*>(&materialindex_)) + sizeof(primitivetypes_));
}

Meshes::~Meshes() {
  // @@protoc_insertion_point(destructor:model.Meshes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Meshes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void Meshes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Meshes::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Meshes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vertices_.Clear();
  normals_.Clear();
  numuvcomponents_.Clear();
  texturecoords_.Clear();
  bones_.Clear();
  faces_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&materialindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&primitivetypes_) -
        reinterpret_cast<char*>(&materialindex_)) + sizeof(primitivetypes_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Meshes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 materialindex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_materialindex(&has_bits);
          materialindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primitivetypes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_primitivetypes(&has_bits);
          primitivetypes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float vertices = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_vertices(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<37>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_vertices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float normals = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_normals(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<45>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_normals(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 numuvcomponents = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_numuvcomponents(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_numuvcomponents(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Meshes.TexturecoordsEntry texturecoords = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_texturecoords(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Meshes.BonesEntry bones = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bones(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Meshes.FaceEntry faces = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_faces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Meshes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Meshes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 materialindex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_materialindex(), target);
  }

  // optional int32 primitivetypes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_primitivetypes(), target);
  }

  // repeated float vertices = 4;
  for (int i = 0, n = this->_internal_vertices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_vertices(i), target);
  }

  // repeated float normals = 5;
  for (int i = 0, n = this->_internal_normals_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_normals(i), target);
  }

  // repeated int32 numuvcomponents = 6;
  for (int i = 0, n = this->_internal_numuvcomponents_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_numuvcomponents(i), target);
  }

  // repeated .model.Meshes.TexturecoordsEntry texturecoords = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_texturecoords_size()); i < n; i++) {
    const auto& repfield = this->_internal_texturecoords(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .model.Meshes.BonesEntry bones = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bones_size()); i < n; i++) {
    const auto& repfield = this->_internal_bones(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .model.Meshes.FaceEntry faces = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_faces_size()); i < n; i++) {
    const auto& repfield = this->_internal_faces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Meshes)
  return target;
}

size_t Meshes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Meshes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float vertices = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_vertices_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_vertices_size());
    total_size += data_size;
  }

  // repeated float normals = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_normals_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_normals_size());
    total_size += data_size;
  }

  // repeated int32 numuvcomponents = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->numuvcomponents_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_numuvcomponents_size());
    total_size += data_size;
  }

  // repeated .model.Meshes.TexturecoordsEntry texturecoords = 7;
  total_size += 1UL * this->_internal_texturecoords_size();
  for (const auto& msg : this->texturecoords_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .model.Meshes.BonesEntry bones = 8;
  total_size += 1UL * this->_internal_bones_size();
  for (const auto& msg : this->bones_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .model.Meshes.FaceEntry faces = 9;
  total_size += 1UL * this->_internal_faces_size();
  for (const auto& msg : this->faces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 materialindex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_materialindex());
    }

    // optional int32 primitivetypes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primitivetypes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Meshes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Meshes*>(
      &from));
}

void Meshes::MergeFrom(const Meshes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Meshes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vertices_.MergeFrom(from.vertices_);
  normals_.MergeFrom(from.normals_);
  numuvcomponents_.MergeFrom(from.numuvcomponents_);
  texturecoords_.MergeFrom(from.texturecoords_);
  bones_.MergeFrom(from.bones_);
  faces_.MergeFrom(from.faces_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      materialindex_ = from.materialindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      primitivetypes_ = from.primitivetypes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Meshes::CopyFrom(const Meshes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Meshes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meshes::IsInitialized() const {
  return true;
}

void Meshes::InternalSwap(Meshes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  vertices_.InternalSwap(&other->vertices_);
  normals_.InternalSwap(&other->normals_);
  numuvcomponents_.InternalSwap(&other->numuvcomponents_);
  texturecoords_.InternalSwap(&other->texturecoords_);
  bones_.InternalSwap(&other->bones_);
  faces_.InternalSwap(&other->faces_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Meshes, primitivetypes_)
      + sizeof(Meshes::primitivetypes_)
      - PROTOBUF_FIELD_OFFSET(Meshes, materialindex_)>(
          reinterpret_cast<char*>(&materialindex_),
          reinterpret_cast<char*>(&other->materialindex_));
}

std::string Meshes::GetTypeName() const {
  return "model.Meshes";
}


// ===================================================================

class Materials_PropertyEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<Materials_PropertyEntry>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_semantic(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_svalue(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Materials_PropertyEntry::Materials_PropertyEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  farray_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Materials.PropertyEntry)
}
Materials_PropertyEntry::Materials_PropertyEntry(const Materials_PropertyEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      farray_(from.farray_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  svalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    svalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_svalue()) {
    svalue_.Set(from._internal_svalue(), 
      GetArenaForAllocation());
  }
  ::memcpy(&semantic_, &from.semantic_,
    static_cast<size_t>(reinterpret_cast<char*>(&fvalue_) -
    reinterpret_cast<char*>(&semantic_)) + sizeof(fvalue_));
  // @@protoc_insertion_point(copy_constructor:model.Materials.PropertyEntry)
}

inline void Materials_PropertyEntry::SharedCtor() {
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
svalue_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  svalue_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&semantic_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fvalue_) -
    reinterpret_cast<char*>(&semantic_)) + sizeof(fvalue_));
}

Materials_PropertyEntry::~Materials_PropertyEntry() {
  // @@protoc_insertion_point(destructor:model.Materials.PropertyEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Materials_PropertyEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.Destroy();
  svalue_.Destroy();
}

void Materials_PropertyEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Materials_PropertyEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Materials.PropertyEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  farray_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      svalue_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&semantic_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fvalue_) -
        reinterpret_cast<char*>(&semantic_)) + sizeof(fvalue_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Materials_PropertyEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 semantic = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_semantic(&has_bits);
          semantic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float farray = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_farray(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<45>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_farray(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float fvalue = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_fvalue(&has_bits);
          fvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string svalue = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_svalue();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Materials_PropertyEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Materials.PropertyEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional int32 semantic = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_semantic(), target);
  }

  // optional int32 index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_index(), target);
  }

  // optional int32 type = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_type(), target);
  }

  // repeated float farray = 5;
  for (int i = 0, n = this->_internal_farray_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_farray(i), target);
  }

  // optional float fvalue = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_fvalue(), target);
  }

  // optional string svalue = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_svalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Materials.PropertyEntry)
  return target;
}

size_t Materials_PropertyEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Materials.PropertyEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float farray = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_farray_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_farray_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional string svalue = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_svalue());
    }

    // optional int32 semantic = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_semantic());
    }

    // optional int32 index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
    }

    // optional int32 type = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional float fvalue = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Materials_PropertyEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Materials_PropertyEntry*>(
      &from));
}

void Materials_PropertyEntry::MergeFrom(const Materials_PropertyEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Materials.PropertyEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  farray_.MergeFrom(from.farray_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_svalue(from._internal_svalue());
    }
    if (cached_has_bits & 0x00000004u) {
      semantic_ = from.semantic_;
    }
    if (cached_has_bits & 0x00000008u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      fvalue_ = from.fvalue_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Materials_PropertyEntry::CopyFrom(const Materials_PropertyEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Materials.PropertyEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Materials_PropertyEntry::IsInitialized() const {
  return true;
}

void Materials_PropertyEntry::InternalSwap(Materials_PropertyEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  farray_.InternalSwap(&other->farray_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &svalue_, lhs_arena,
      &other->svalue_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Materials_PropertyEntry, fvalue_)
      + sizeof(Materials_PropertyEntry::fvalue_)
      - PROTOBUF_FIELD_OFFSET(Materials_PropertyEntry, semantic_)>(
          reinterpret_cast<char*>(&semantic_),
          reinterpret_cast<char*>(&other->semantic_));
}

std::string Materials_PropertyEntry::GetTypeName() const {
  return "model.Materials.PropertyEntry";
}


// ===================================================================

class Materials::_Internal {
 public:
};

Materials::Materials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  properties_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Materials)
}
Materials::Materials(const Materials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      properties_(from.properties_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:model.Materials)
}

inline void Materials::SharedCtor() {
}

Materials::~Materials() {
  // @@protoc_insertion_point(destructor:model.Materials)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Materials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Materials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Materials::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Materials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  properties_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Materials::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .model.Materials.PropertyEntry properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Materials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Materials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .model.Materials.PropertyEntry properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Materials)
  return target;
}

size_t Materials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Materials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .model.Materials.PropertyEntry properties = 1;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Materials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Materials*>(
      &from));
}

void Materials::MergeFrom(const Materials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Materials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  properties_.MergeFrom(from.properties_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Materials::CopyFrom(const Materials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Materials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Materials::IsInitialized() const {
  return true;
}

void Materials::InternalSwap(Materials* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  properties_.InternalSwap(&other->properties_);
}

std::string Materials::GetTypeName() const {
  return "model.Materials";
}


// ===================================================================

class Animations_keys::_Internal {
 public:
  using HasBits = decltype(std::declval<Animations_keys>()._has_bits_);
  static void set_has_val1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Animations_keys::Animations_keys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  val2_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Animations.keys)
}
Animations_keys::Animations_keys(const Animations_keys& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      val2_(from.val2_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  val1_ = from.val1_;
  // @@protoc_insertion_point(copy_constructor:model.Animations.keys)
}

inline void Animations_keys::SharedCtor() {
val1_ = 0;
}

Animations_keys::~Animations_keys() {
  // @@protoc_insertion_point(destructor:model.Animations.keys)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Animations_keys::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Animations_keys::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Animations_keys::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Animations.keys)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  val2_.Clear();
  val1_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Animations_keys::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 val1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_val1(&has_bits);
          val1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float val2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_val2(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<21>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_val2(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Animations_keys::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Animations.keys)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 val1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_val1(), target);
  }

  // repeated float val2 = 2;
  for (int i = 0, n = this->_internal_val2_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_val2(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Animations.keys)
  return target;
}

size_t Animations_keys::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Animations.keys)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float val2 = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_val2_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_val2_size());
    total_size += data_size;
  }

  // optional int32 val1 = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_val1());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Animations_keys::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Animations_keys*>(
      &from));
}

void Animations_keys::MergeFrom(const Animations_keys& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Animations.keys)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  val2_.MergeFrom(from.val2_);
  if (from._internal_has_val1()) {
    _internal_set_val1(from._internal_val1());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Animations_keys::CopyFrom(const Animations_keys& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Animations.keys)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Animations_keys::IsInitialized() const {
  return true;
}

void Animations_keys::InternalSwap(Animations_keys* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  val2_.InternalSwap(&other->val2_);
  swap(val1_, other->val1_);
}

std::string Animations_keys::GetTypeName() const {
  return "model.Animations.keys";
}


// ===================================================================

class Animations_Channel::_Internal {
 public:
  using HasBits = decltype(std::declval<Animations_Channel>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prestate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_poststate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Animations_Channel::Animations_Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  positionkeys_(arena),
  rotationkeys_(arena),
  scalingkeys_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Animations.Channel)
}
Animations_Channel::Animations_Channel(const Animations_Channel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      positionkeys_(from.positionkeys_),
      rotationkeys_(from.rotationkeys_),
      scalingkeys_(from.scalingkeys_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&prestate_, &from.prestate_,
    static_cast<size_t>(reinterpret_cast<char*>(&poststate_) -
    reinterpret_cast<char*>(&prestate_)) + sizeof(poststate_));
  // @@protoc_insertion_point(copy_constructor:model.Animations.Channel)
}

inline void Animations_Channel::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&prestate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&poststate_) -
    reinterpret_cast<char*>(&prestate_)) + sizeof(poststate_));
}

Animations_Channel::~Animations_Channel() {
  // @@protoc_insertion_point(destructor:model.Animations.Channel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Animations_Channel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void Animations_Channel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Animations_Channel::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Animations.Channel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  positionkeys_.Clear();
  rotationkeys_.Clear();
  scalingkeys_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&prestate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&poststate_) -
        reinterpret_cast<char*>(&prestate_)) + sizeof(poststate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Animations_Channel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prestate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_prestate(&has_bits);
          prestate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 poststate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_poststate(&has_bits);
          poststate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Animations.keys positionkeys = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_positionkeys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Animations.keys rotationkeys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rotationkeys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Animations.keys scalingkeys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_scalingkeys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Animations_Channel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Animations.Channel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 prestate = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_prestate(), target);
  }

  // optional int32 poststate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_poststate(), target);
  }

  // repeated .model.Animations.keys positionkeys = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_positionkeys_size()); i < n; i++) {
    const auto& repfield = this->_internal_positionkeys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .model.Animations.keys rotationkeys = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rotationkeys_size()); i < n; i++) {
    const auto& repfield = this->_internal_rotationkeys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .model.Animations.keys scalingkeys = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_scalingkeys_size()); i < n; i++) {
    const auto& repfield = this->_internal_scalingkeys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Animations.Channel)
  return target;
}

size_t Animations_Channel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Animations.Channel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .model.Animations.keys positionkeys = 4;
  total_size += 1UL * this->_internal_positionkeys_size();
  for (const auto& msg : this->positionkeys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .model.Animations.keys rotationkeys = 5;
  total_size += 1UL * this->_internal_rotationkeys_size();
  for (const auto& msg : this->rotationkeys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .model.Animations.keys scalingkeys = 6;
  total_size += 1UL * this->_internal_scalingkeys_size();
  for (const auto& msg : this->scalingkeys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 prestate = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prestate());
    }

    // optional int32 poststate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_poststate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Animations_Channel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Animations_Channel*>(
      &from));
}

void Animations_Channel::MergeFrom(const Animations_Channel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Animations.Channel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  positionkeys_.MergeFrom(from.positionkeys_);
  rotationkeys_.MergeFrom(from.rotationkeys_);
  scalingkeys_.MergeFrom(from.scalingkeys_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      prestate_ = from.prestate_;
    }
    if (cached_has_bits & 0x00000004u) {
      poststate_ = from.poststate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Animations_Channel::CopyFrom(const Animations_Channel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Animations.Channel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Animations_Channel::IsInitialized() const {
  return true;
}

void Animations_Channel::InternalSwap(Animations_Channel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  positionkeys_.InternalSwap(&other->positionkeys_);
  rotationkeys_.InternalSwap(&other->rotationkeys_);
  scalingkeys_.InternalSwap(&other->scalingkeys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Animations_Channel, poststate_)
      + sizeof(Animations_Channel::poststate_)
      - PROTOBUF_FIELD_OFFSET(Animations_Channel, prestate_)>(
          reinterpret_cast<char*>(&prestate_),
          reinterpret_cast<char*>(&other->prestate_));
}

std::string Animations_Channel::GetTypeName() const {
  return "model.Animations.Channel";
}


// ===================================================================

class Animations::_Internal {
 public:
  using HasBits = decltype(std::declval<Animations>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tickspersecond(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Animations::Animations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channels_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Animations)
}
Animations::Animations(const Animations& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&tickspersecond_, &from.tickspersecond_,
    static_cast<size_t>(reinterpret_cast<char*>(&duration_) -
    reinterpret_cast<char*>(&tickspersecond_)) + sizeof(duration_));
  // @@protoc_insertion_point(copy_constructor:model.Animations)
}

inline void Animations::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tickspersecond_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&duration_) -
    reinterpret_cast<char*>(&tickspersecond_)) + sizeof(duration_));
}

Animations::~Animations() {
  // @@protoc_insertion_point(destructor:model.Animations)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Animations::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void Animations::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Animations::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Animations)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channels_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&tickspersecond_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&duration_) -
        reinterpret_cast<char*>(&tickspersecond_)) + sizeof(duration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Animations::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tickspersecond = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tickspersecond(&has_bits);
          tickspersecond_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_duration(&has_bits);
          duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Animations.Channel channels = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_channels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Animations::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Animations)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 tickspersecond = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_tickspersecond(), target);
  }

  // optional int32 duration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_duration(), target);
  }

  // repeated .model.Animations.Channel channels = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_channels_size()); i < n; i++) {
    const auto& repfield = this->_internal_channels(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Animations)
  return target;
}

size_t Animations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Animations)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .model.Animations.Channel channels = 4;
  total_size += 1UL * this->_internal_channels_size();
  for (const auto& msg : this->channels_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 tickspersecond = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tickspersecond());
    }

    // optional int32 duration = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_duration());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Animations::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Animations*>(
      &from));
}

void Animations::MergeFrom(const Animations& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Animations)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channels_.MergeFrom(from.channels_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      tickspersecond_ = from.tickspersecond_;
    }
    if (cached_has_bits & 0x00000004u) {
      duration_ = from.duration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Animations::CopyFrom(const Animations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Animations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Animations::IsInitialized() const {
  return true;
}

void Animations::InternalSwap(Animations* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  channels_.InternalSwap(&other->channels_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Animations, duration_)
      + sizeof(Animations::duration_)
      - PROTOBUF_FIELD_OFFSET(Animations, tickspersecond_)>(
          reinterpret_cast<char*>(&tickspersecond_),
          reinterpret_cast<char*>(&other->tickspersecond_));
}

std::string Animations::GetTypeName() const {
  return "model.Animations";
}


// ===================================================================

class Model::_Internal {
 public:
  using HasBits = decltype(std::declval<Model>()._has_bits_);
  static const ::model::Node& rootnode(const Model* msg);
  static void set_has_rootnode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::model::Node&
Model::_Internal::rootnode(const Model* msg) {
  return *msg->rootnode_;
}
Model::Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  meshes_(arena),
  materials_(arena),
  animations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:model.Model)
}
Model::Model(const Model& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      meshes_(from.meshes_),
      materials_(from.materials_),
      animations_(from.animations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_rootnode()) {
    rootnode_ = new ::model::Node(*from.rootnode_);
  } else {
    rootnode_ = nullptr;
  }
  flags_ = from.flags_;
  // @@protoc_insertion_point(copy_constructor:model.Model)
}

inline void Model::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rootnode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&rootnode_)) + sizeof(flags_));
}

Model::~Model() {
  // @@protoc_insertion_point(destructor:model.Model)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Model::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete rootnode_;
}

void Model::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Model::Clear() {
// @@protoc_insertion_point(message_clear_start:model.Model)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  meshes_.Clear();
  materials_.Clear();
  animations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(rootnode_ != nullptr);
    rootnode_->Clear();
  }
  flags_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Model::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .model.Node rootnode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rootnode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Meshes meshes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_meshes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Materials materials = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_materials(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .model.Animations animations = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_animations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Model::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:model.Model)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .model.Node rootnode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rootnode(this),
        _Internal::rootnode(this).GetCachedSize(), target, stream);
  }

  // optional int32 flags = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_flags(), target);
  }

  // repeated .model.Meshes meshes = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_meshes_size()); i < n; i++) {
    const auto& repfield = this->_internal_meshes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .model.Materials materials = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_materials_size()); i < n; i++) {
    const auto& repfield = this->_internal_materials(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .model.Animations animations = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_animations_size()); i < n; i++) {
    const auto& repfield = this->_internal_animations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:model.Model)
  return target;
}

size_t Model::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:model.Model)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .model.Meshes meshes = 3;
  total_size += 1UL * this->_internal_meshes_size();
  for (const auto& msg : this->meshes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .model.Materials materials = 4;
  total_size += 1UL * this->_internal_materials_size();
  for (const auto& msg : this->materials_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .model.Animations animations = 5;
  total_size += 1UL * this->_internal_animations_size();
  for (const auto& msg : this->animations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .model.Node rootnode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rootnode_);
    }

    // optional int32 flags = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Model::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Model*>(
      &from));
}

void Model::MergeFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:model.Model)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  meshes_.MergeFrom(from.meshes_);
  materials_.MergeFrom(from.materials_);
  animations_.MergeFrom(from.animations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_rootnode()->::model::Node::MergeFrom(from._internal_rootnode());
    }
    if (cached_has_bits & 0x00000002u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Model::CopyFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:model.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Model::IsInitialized() const {
  return true;
}

void Model::InternalSwap(Model* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  meshes_.InternalSwap(&other->meshes_);
  materials_.InternalSwap(&other->materials_);
  animations_.InternalSwap(&other->animations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Model, flags_)
      + sizeof(Model::flags_)
      - PROTOBUF_FIELD_OFFSET(Model, rootnode_)>(
          reinterpret_cast<char*>(&rootnode_),
          reinterpret_cast<char*>(&other->rootnode_));
}

std::string Model::GetTypeName() const {
  return "model.Model";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace model
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::model::Node*
Arena::CreateMaybeMessage< ::model::Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Node >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Meshes_TexturecoordsEntry*
Arena::CreateMaybeMessage< ::model::Meshes_TexturecoordsEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Meshes_TexturecoordsEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Meshes_BonesWeight*
Arena::CreateMaybeMessage< ::model::Meshes_BonesWeight >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Meshes_BonesWeight >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Meshes_BonesEntry*
Arena::CreateMaybeMessage< ::model::Meshes_BonesEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Meshes_BonesEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Meshes_FaceEntry*
Arena::CreateMaybeMessage< ::model::Meshes_FaceEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Meshes_FaceEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Meshes*
Arena::CreateMaybeMessage< ::model::Meshes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Meshes >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Materials_PropertyEntry*
Arena::CreateMaybeMessage< ::model::Materials_PropertyEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Materials_PropertyEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Materials*
Arena::CreateMaybeMessage< ::model::Materials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Materials >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Animations_keys*
Arena::CreateMaybeMessage< ::model::Animations_keys >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Animations_keys >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Animations_Channel*
Arena::CreateMaybeMessage< ::model::Animations_Channel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Animations_Channel >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Animations*
Arena::CreateMaybeMessage< ::model::Animations >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Animations >(arena);
}
template<> PROTOBUF_NOINLINE ::model::Model*
Arena::CreateMaybeMessage< ::model::Model >(Arena* arena) {
  return Arena::CreateMessageInternal< ::model::Model >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
